// Generated by dts-bundle-generator v9.5.1

/// <reference types="googlepay" />

import { AnyObject } from 'final-form';

export type Subscriber<T> = (value: T) => void;
export type Unsubscriber = () => void;
export type StoreSubscriber<T> = Subscriber<T>;
export type StoreUnsubscriber = () => void;
export type StoreUpdater<T> = (value: T) => T;
export type StoreInvalidator<T> = (value?: T) => void;
export interface WithGetter<T> {
	get value(): T;
	getValue(): T;
}
export interface Subscribable<T> {
	subscribe(run: StoreSubscriber<T>, invalidate?: StoreInvalidator<T>): StoreUnsubscriber;
}
export type Stores = Subscribable<any> | [
	Subscribable<any>,
	...Array<Subscribable<any>>
] | Array<Subscribable<any>>;
export type Readable<T> = WithGetter<T> & Subscribable<T>;
export type StoresValues<T> = T extends Subscribable<infer U> ? U : {
	[K in keyof T]: T[K] extends Subscribable<infer U> ? U : never;
};
declare class Derived<T, S extends Stores = Stores> implements Subscribable<T>, WithGetter<T> {
	store: Subscribable<T>;
	constructor(stores: S, updater: (values: StoresValues<S>) => T, defaultValue?: T);
	get value(): T;
	getValue(): T;
	subscribe(run: StoreSubscriber<T>, invalidate?: any): Unsubscriber;
}
export interface SvelteWritable<T> extends Subscribable<T> {
	/**
	 * Set value and inform subscribers.
	 * @param value to set
	 */
	set(value: T): void;
	/**
	 * Update value using callback and inform subscribers.
	 * @param updater callback
	 */
	update(updater: StoreUpdater<T>): void;
}
declare class Writable<T> implements Subscribable<T>, WithGetter<T>, SvelteWritable<T> {
	store: SvelteWritable<T>;
	constructor(defaultValue?: T);
	get value(): T;
	set value(value: T);
	getValue(): T;
	subscribe(listener: Subscriber<T>, invalidate?: any): Unsubscriber;
	set(value: T): void;
	update(updater: StoreUpdater<T>): this;
	patchStore(patch: any): this;
}
declare const EventType: {
	readonly DEBUG: "DEBUG";
	readonly INFO: "INFO";
	readonly ERROR: "ERROR";
	readonly SUCCESS: "SUCCESS";
	readonly WARNING: "WARNING";
	readonly PERFORMANCE: "PERFORMANCE";
	readonly UI: "UI";
	readonly NETWORK: "NETWORK";
};
declare class Event$1<Payload = any, Code = string> {
	code: Code;
	dateString: string;
	clientDate: string | null;
	type: keyof typeof EventType;
	payload?: Payload;
	constructor({ code, payload, type }: {
		code: Code;
		type?: keyof typeof EventType;
		payload?: Payload;
	});
}
type EventListener$1<EventType extends Event$1> = (event: EventType) => void;
export type EventListenerTerminator = () => void;
export type EventBusScopes = {
	[key: string]: string[];
};
declare class EventBus<EventType extends Event$1 = Event$1> {
	listeners: {
		[key: string]: EventListener$1<EventType>[];
	};
	history: EventType[];
	queue: EventType[];
	scopes: EventBusScopes;
	private _buses;
	constructor({ scopes }: {
		scopes: EventBusScopes;
	});
	subscribe(listener: EventListener$1<EventType>, scopes?: string[]): EventListenerTerminator;
	unsubscribe(listener: EventListener$1<EventType>, scopes?: string[]): void;
	post(event: EventType): void;
	forwardToBus(bus: EventBus): () => void;
	addScopes(scopes: EventBusScopes): void;
	getReport(): {
		history: EventType[];
	};
	private applyServerTimeOffset;
	_sort(a: Event$1<any>, b: Event$1<any>): number;
	_processQueue(): void;
	_getListenersForScopes(scopes: string[]): EventListener$1<EventType>[];
	_getScopesForCode(code: string): string[];
	flush(): void;
}
declare const Environments: readonly [
	"development",
	"test",
	"sandbox",
	"production"
];
export type EnvironmentTarget = (typeof Environments)[number];
export interface Environment {
	target: EnvironmentTarget;
	apiKey: string;
	entityId: string;
}
export declare const Partners: {
	readonly aci: "aci";
	readonly adyen: "adyen";
	readonly alma: "alma";
	readonly axepta: "axepta";
	readonly braintree: "braintree";
	readonly centralpay: "centralpay";
	readonly checkout: "checkout";
	readonly cofidis: "cofidis";
	readonly dalenys: "dalenys";
	readonly easycollect: "easycollect";
	readonly fintecture: "fintecture";
	readonly floa: "floa";
	readonly gocardless: "gocardless";
	readonly hipay: "hipay";
	readonly illicado: "illicado";
	readonly ingenico: "ingenico";
	readonly klarna: "klarna";
	readonly mercanet: "mercanet";
	readonly oney: "oney";
	readonly oneycard: "oneycard";
	readonly paybox: "paybox";
	readonly payline: "payline";
	readonly paypal: "paypal";
	readonly payzen: "payzen";
	readonly purse: "purse";
	readonly redsys: "redsys";
	readonly riverty: "riverty";
	readonly scalapay: "scalapay";
	readonly scellius: "scellius";
	readonly sipsv2: "sipsv2";
	readonly slimpay: "slimpay";
	readonly sogecommerce: "sogecommerce";
	readonly sogenactif: "sogenactif";
	readonly stripe: "stripe";
	readonly systempay: "systempay";
	readonly worldpay: "worldpay";
};
export type Partner = (typeof Partners)[keyof typeof Partners];
export declare const Methods: {
	readonly applepay: "applepay";
	readonly bancontact: "bancontact";
	readonly bizum: "bizum";
	readonly bnpl: "bnpl";
	readonly buybox: "buybox";
	readonly cb10x: "cb10x";
	readonly cb10xsansfrais: "cb10xsansfrais";
	readonly cb12x: "cb12x";
	readonly cb12xsansfrais: "cb12xsansfrais";
	readonly cb2x: "cb2x";
	readonly cb3x: "cb3x";
	readonly cb3xsansfrais: "cb3xsansfrais";
	readonly cb4x: "cb4x";
	readonly cb4xsansfrais: "cb4xsansfrais";
	readonly "3x": "3x";
	readonly "6x": "6x";
	readonly "9x": "9x";
	readonly "12x": "12x";
	readonly comptant: "comptant";
	readonly creditcard: "creditcard";
	readonly giftcard: "giftcard";
	readonly googlepay: "googlepay";
	readonly ideal: "ideal";
	readonly installments: "installments";
	readonly instantpayment: "instantpayment";
	readonly invoice: "invoice";
	readonly loan: "loan";
	readonly maxxing: "maxxing";
	readonly mbway: "mbway";
	readonly multibanco: "multibanco";
	readonly paybylink: "paybylink";
	readonly paylater: "paylater";
	readonly paypal: "paypal";
	readonly revolving: "revolving";
	readonly sepa: "sepa";
	readonly sdd: "sdd";
	readonly sepainstant: "sepainstant";
	readonly separecurrent: "separecurrent";
	readonly sepasingle: "sepasingle";
	readonly slimcollect: "slimcollect";
	readonly smart_transfer: "smart_transfer";
	readonly twint: "twint";
	readonly wallet: "wallet";
	readonly "cb3x-paybylink": "cb3x-paybylink";
	readonly "cb4x-paybylink": "cb4x-paybylink";
	readonly xpay: "xpay";
};
export type Method = (typeof Methods)[keyof typeof Methods];
declare const VaultVendors: {
	readonly pci_proxy: "pci_proxy";
	readonly purse: "purse";
};
export type VaultVendor = keyof typeof VaultVendors;
declare const CardSchemes: {
	readonly CARTE_BANCAIRE: "CARTE_BANCAIRE";
	readonly VISA: "VISA";
	readonly MASTERCARD: "MASTERCARD";
	readonly AMERICAN_EXPRESS: "AMERICAN_EXPRESS";
	readonly MAESTRO: "MAESTRO";
	readonly DINERS_CLUB: "DINERS_CLUB";
	readonly DISCOVER: "DISCOVER";
	readonly UNIONPAY: "UNIONPAY";
	readonly JCB: "JCB";
	readonly ONEY: "ONEY";
	readonly OTHER: "OTHER";
};
export type CardScheme = (typeof CardSchemes)[keyof typeof CardSchemes];
export type IntegratedToken = {
	id: string;
	value: string;
	uniqueness_token: string;
	expiration_date: string;
	owner_reference: string;
	merchant: string;
	favorite: boolean;
	pin_code?: string;
	description: {
		brand_name?: string;
		display_token?: string;
		holder_name?: string;
		masked_pan?: string;
	};
	payment_id: {
		origin: string;
		partner: Partner;
		method?: Method;
	};
	name?: string;
};
export interface MethodConfiguration {
	stable: boolean;
	template: string;
	labels: string[];
	position: number;
	vault?: {
		supported_brands: CardScheme[];
		token_scope: string;
		vendor: VaultVendor | "none";
		external_three_ds_enabled?: boolean;
	};
	settings: {
		registration_mode?: string;
		save_token?: boolean;
		direct_debit?: boolean;
		payment_min_amount?: number;
		payment_max_amount?: number;
		usage_per_session_limit?: number;
		merchant_specifics?: {
			integration_mode?: "redirection" | "popup";
		};
	};
}
export type LegacyPaymentSession = {
	id: string;
	amount?: number;
	redirection?: string;
	expiration_date: string;
	success?: string;
	failure?: string;
	currency_code: string;
	protocols: {
		[key in Partner]?: {
			[key in Method]?: {
				configurations: MethodConfiguration;
				integrated_tokens?: IntegratedToken[];
			};
		};
	};
	vault?: SessionVault;
};
export type SessionVault = {
	vendor_front_data: {
		purse?: {
			tenant_id: string;
		};
		pci_proxy: {
			merchant_id: string;
		};
	};
};
export type OrchestrationPaymentSession = string;
export type OnePayWalletSession = {
	expiration_date: string;
	session_id: string;
	owner_reference: string;
	merchant: string;
};
declare const PurseErrors: {
	readonly SESSION_MALFORMED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly WIDGET_DATA_MALFORMED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SESSION_NOT_SET_YET: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SESSION_EXPIRED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SESSION_ALREADY_SUBMITTED_ERROR: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly API_404: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly API_ROOT_IS_MISSING: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly PAYMENT_METHOD_NOT_FOUND_IN_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly PAYMENT_TOKEN_NOT_FOUND_IN_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly METHOD_IS_NOT_SIMULABLE: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly INVALID_LOAN_SIMULATION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MEAN_OF_PAYMENT_CANT_BE_REGISTERED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly INVALID_TAKE_AMOUNT: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_NOT_REGISTERABLE: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_NOT_REGISTERED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_NAME_EXISTS: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MISSING_TOKEN: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MISSING_WALLET_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly INVALID_TOKEN_NAME: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly FAILED_TO_DELETE_ALL_TOKENS: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly FAILED_TO_ADD_TOKEN: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SECONDARY_METHOD_REQUIRED_CVV: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SECONDARY_METHOD_WRONG_PAN_FORMAT: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SECONDARY_METHOD_WRONG_CVV_FORMAT: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SECONDARY_METHOD_TAKE_POLICY_VIOLATED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MISSING_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly USAGE_LIMIT_ERROR: {
		code: string;
		message: string;
		documentationLink: string;
	};
};
export type PurseErrorCodes = keyof typeof PurseErrors;
export type JsonSerializable = string | number | boolean | null | {
	[key: string]: JsonSerializable | undefined;
} | JsonSerializable[];
declare class PurseError extends Error {
	readonly code: PurseErrorCodes;
	readonly documentationLink: string;
	readonly additionalPayload?: JsonSerializable | Error;
	constructor(error: (typeof PurseErrors)[PurseErrorCodes], additionalPayload?: JsonSerializable | Error);
}
declare const StatusCodes: {
	readonly SUCCEEDED: "SUCCEEDED";
	readonly FAILED: "FAILED";
	readonly CARD_EXPIRED: "CARD_EXPIRED";
	readonly UNKNOWN: "UNKNOWN";
	readonly FORCED: "FORCED";
	readonly AMOUNT_EXCEEDED: "AMOUNT_EXCEEDED";
	readonly BLOCKED_BY_CUSTOMER: "BLOCKED_BY_CUSTOMER";
	readonly BLOCKED_CARD: "BLOCKED_CARD";
	readonly DUPLICATED_TRANSACTION: "DUPLICATED_TRANSACTION";
	readonly EXPIRED_AUTHORIZATION: "EXPIRED_AUTHORIZATION";
	readonly INSUFFICIENT_FUNDS: "INSUFFICIENT_FUNDS";
	readonly REFUND_REQUESTED_TOO_LATE: "REFUND_REQUESTED_TOO_LATE";
	readonly REJECTED_BANK: "REJECTED_BANK";
	readonly REJECTED_BY_RISK_CHECKS: "REJECTED_BY_RISK_CHECKS";
	readonly TECHNICAL_ISSUE_TO_CONTACT_PARTNER: "TECHNICAL_ISSUE_TO_CONTACT_PARTNER";
	readonly TRANSACTION_NOT_SUPPORTED_BY_CARD: "TRANSACTION_NOT_SUPPORTED_BY_CARD";
	readonly TRANSACTION_NOT_SUPPORTED_BY_MERCHANT_ACCOUNT: "TRANSACTION_NOT_SUPPORTED_BY_MERCHANT_ACCOUNT";
	readonly UNKNOWN_CARD: "UNKNOWN_CARD";
	readonly WAITING_PARTNER_RESPONSE: "WAITING_PARTNER_RESPONSE";
	readonly WAITING_ONEPAY_ACTION: "WAITING_ONEPAY_ACTION";
	readonly CARD_ALREADY_ACTIVE: "CARD_ALREADY_ACTIVE";
	readonly TECHNICAL_ISSUE_DURING_AUTHENTICATION_CHECK: "TECHNICAL_ISSUE_DURING_AUTHENTICATION_CHECK";
	readonly WRONG_CARD_DATA: "WRONG_CARD_DATA";
	readonly BAD_REQUEST: "BAD_REQUEST";
	readonly CARD_IS_NOT_ACTIVE: "CARD_IS_NOT_ACTIVE";
	readonly ABORTED_BY_CUSTOMER: "ABORTED_BY_CUSTOMER";
	readonly UNCERTAIN: "UNCERTAIN";
};
export type StatusCode = (typeof StatusCodes)[keyof typeof StatusCodes];
declare const StatusStates: {
	readonly SUCCESS: "SUCCESS";
	readonly ERROR: "ERROR";
	readonly UNCERTAIN: "UNCERTAIN";
	readonly FAILED: "FAILED";
	readonly WAITING: "WAITING";
};
export type StatusState = (typeof StatusStates)[keyof typeof StatusStates];
declare const TransactionActions: {
	readonly INIT: "INIT";
	readonly APPLY: "APPLY";
	readonly VOID: "VOID";
	readonly CAPTURE: "CAPTURE";
	readonly REFUND: "REFUND";
	readonly AUTHORIZE: "AUTHORIZE";
};
export type TransactionAction = (typeof TransactionActions)[keyof typeof TransactionActions];
export type ActionStatus = {
	action: TransactionAction;
	state: StatusState;
	description?: string;
	code: StatusCode;
};
export interface ItemPayload {
	method: Method;
	partner: Partner;
	amount: number;
	payment_data: any;
	partner_data: any;
	order?: any;
	payment_preferences: any;
	step_id?: number | null;
}
export type ValidateItemPayload = ItemPayload;
export type InitData<PluginResult = Record<never, never>> = {
	id: string;
	session_id?: string;
	date: string;
	method: string;
	partner: string;
	step_id: number;
	status: ActionStatus;
	plugin_result: PluginResult & {
		status?: string;
		amount?: number;
	};
};
export type InitXPaysData<Logs = Record<never, never>> = InitData<Logs> & {
	vault_vendor_token_id: string;
};
export type Init3DSData<Logs = Record<never, never>> = InitData<Logs>;
export type ItemValidationData<Result = Record<never, never>> = {
	id: string;
	date: string;
	method: string;
	partner: string;
	session_id: string;
	transaction_id: string;
	plugin_result: Result;
	status: {
		action: TransactionAction;
		state: StatusState;
		description?: string;
		code: StatusCode;
	};
};
export interface SecondaryPluginInitPayload {
	partner: Partner;
	method: Method;
	amount: number;
	order: any;
	partner_data: any;
	payment_preferences: any;
	payment_data: {
		card?: {
			csc?: string;
			number?: string;
		};
		voucher_number?: string;
	};
}
export type ValidationResultData<PluginLogs = void> = {
	results: ItemValidationData<PluginLogs extends void ? Record<never, never> : {
		logs: PluginLogs;
	}>[];
	redirection: {
		should_submit_widget?: boolean;
		url?: string;
		form?: string;
		name?: string;
	};
	global_status: StatusState;
};
export type APIEnv = Environment & {
	paymentAPIRoot?: string;
	datetimeAPIRoot?: string;
	walletAPIRoot?: string;
};
export interface LoanProduct {
	amount: number;
	currency_code: string;
}
export interface LoanSimulation {
	/** first installment amount **/
	initialInstallmentAmount: number;
	/** last installment amount **/
	finalInstallmentAmount: number;
	/** Cost of recurrent installments **/
	installmentAmount: number;
	/** Cost of the loan (not including amount) **/
	totalCost: number;
	/** Amount of the loan (including cost) **/
	totalAmount: number;
	/** Number of installments **/
	installmentCount: number;
	/** Some loan simulation will provide a legal text to display next to the offer **/
	legalText?: string;
	/** Annual Percentage Rate Cost **/
	aprc?: number;
}
export type WalletItem = {
	id: string;
	name?: string;
};
declare class ApiError extends PurseError {
	readonly path: string;
	readonly error: string;
	constructor(error: (typeof PurseErrors)[PurseErrorCodes], path?: string, errorCode?: string, message?: string);
}
export interface MonitoringApiEventMessage<Event> {
	instanceId?: string;
	entityId?: string;
	paymentSessionId?: string;
	version?: string;
	env?: EnvironmentTarget;
	event: Event;
}
export interface PaymentAPI {
	env: Pick<APIEnv, "apiKey" | "paymentAPIRoot" | "entityId" | "target">;
	setSessionId(id: string): void;
	init<Logs = Record<never, never>>(data: ItemPayload): Promise<InitData<Logs>>;
	initXPays<Logs = Record<never, never>>(data: ItemPayload): Promise<InitXPaysData<Logs>>;
	init3DS<Logs = Record<never, never>>(data: ItemPayload): Promise<Init3DSData<Logs>>;
	validate(data: ValidateItemPayload[]): Promise<ValidationResultData>;
	getSimulation(partner: string, method: string, body: LoanProduct): Promise<LoanSimulation>;
}
export interface WalletAPI {
	setSession(session: {
		id: string;
	}): void;
	getTokens(): Promise<WalletItem[]>;
	deleteToken(data: {
		id: string;
	}): Promise<void>;
	editTokenName(data: {
		id: string;
		name: string;
		reason?: string;
	}): Promise<void>;
	deleteAllTokens(): Promise<void>;
}
export interface MonitoringAPI<E> {
	getApiKey(): string;
	patchExtrasData(E: Pick<MonitoringApiEventMessage<E>, "instanceId" | "entityId" | "paymentSessionId" | "version">): void;
	sendLogs(E: E[]): void;
}
export type APIPaths = {
	payment?: string;
	wallet?: string;
	logs?: string;
	datetime?: string;
};
declare class FetchMonitoringAPI<Event> implements MonitoringAPI<Event> {
	private readonly root;
	private readonly env;
	private readonly apiKey;
	private extras;
	constructor(env: EnvironmentTarget, root: string, apiKey: string);
	getApiKey(): string;
	patchExtrasData: (payload: Partial<Pick<MonitoringApiEventMessage<Event>, "instanceId" | "entityId" | "paymentSessionId" | "version">>) => void;
	sendLogs: (events: Event[]) => void;
}
export declare type ButtonOptions = google.payments.api.ButtonOptions;
export declare interface CreditCardValidateUiResult {
	cardNumber: string | null;
	cvv: string | null;
	expiryDate: string | null;
	holderName: string | null;
}
export declare type DeepPartial<T> = T extends any[] ? T : {
	[P in keyof T]?: DeepPartial<T[P]>;
};
export declare type ErrorPayload = {
	reason?: string;
} & Record<string, any>;
export declare type EventCode = (typeof Events)[keyof typeof Events]["code"];
declare const Events: {
	readonly clientError: {
		readonly code: "clientError";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly clientNotFound: {
		readonly code: "clientNotFound";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly cantDownloadPluginSources: {
		readonly code: "cantDownloadPluginSources";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly clientNotProperlyDestroyed: {
		readonly code: "clientNotProperlyDestroyed";
		readonly topics: readonly [
			"info"
		];
	};
	readonly disconnected: {
		readonly code: "disconnected";
		readonly topics: readonly [
			"info"
		];
	};
	readonly died: {
		readonly code: "died";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly formDataChanged: {
		readonly code: "formDataChanged";
		readonly topics: readonly [
			"info"
		];
	};
	readonly fulfilled: {
		readonly code: "fulfilled";
		readonly topics: readonly [
			"info",
			"fulfilled"
		];
	};
	readonly initFailed: {
		readonly code: "initFailed";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly misconfigured: {
		readonly code: "misconfigured";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly modalIn: {
		readonly code: "modalIn";
		readonly topics: readonly [
			"info"
		];
	};
	readonly modalOut: {
		readonly code: "modalOut";
		readonly topics: readonly [
			"info"
		];
	};
	readonly optionsSet: {
		readonly code: "optionsSet";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginClientDestroyed: {
		readonly code: "pluginClientDestroyed";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginExtraSourcesLoaded: {
		readonly code: "pluginExtraSourcesLoaded";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginPostValidation: {
		readonly code: "pluginPostValidation";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginPreValidation: {
		readonly code: "pluginPreValidation";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginSessionSet: {
		readonly code: "pluginSessionSet";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginSourcesLoaded: {
		readonly code: "pluginSourcesLoaded";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginIsIncompatibleWithInterface: {
		readonly code: "pluginIsIncompatibleWithInterface";
		readonly topics: readonly [
			"info"
		];
	};
	readonly pluginIsIncompatibleWithClient: {
		readonly code: "pluginIsIncompatibleWithClient";
		readonly topics: readonly [
			"error"
		];
	};
	readonly ready: {
		readonly code: "ready";
		readonly topics: readonly [
			"info"
		];
	};
	readonly redirect: {
		readonly code: "redirect";
		readonly topics: readonly [
			"info"
		];
	};
	readonly requestValidate: {
		readonly code: "requestValidate";
		readonly topics: readonly [
			"requestValidate"
		];
	};
	readonly sourceListLoaded: {
		readonly code: "sourceListLoaded";
		readonly topics: readonly [
			"info"
		];
	};
	readonly sourceLoaded: {
		readonly code: "sourceLoaded";
		readonly topics: readonly [
			"info"
		];
	};
	readonly other: {
		readonly code: "other";
		readonly topics: readonly [
			"info"
		];
	};
	readonly methodSelected: {
		readonly code: "methodSelected";
		readonly topics: readonly [
			"info",
			"methodSelected"
		];
	};
	readonly methodUnselected: {
		readonly code: "methodUnselected";
		readonly topics: readonly [
			"info",
			"methodUnselected"
		];
	};
	readonly partnerError: {
		readonly code: "partnerError";
		readonly topics: readonly [
			"error",
			"partnerError"
		];
	};
	readonly change: {
		readonly code: "change";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly focus: {
		readonly code: "focus";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly blur: {
		readonly code: "blur";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly keyup: {
		readonly code: "keyup";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly keydown: {
		readonly code: "keydown";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly brandDetected: {
		readonly code: "brandDetected";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly supportedBrandsChanged: {
		readonly code: "supportedBrandsChanged";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly selectedBrandChanged: {
		readonly code: "selectedBrandChanged";
		readonly topics: readonly [
			"hostedFields"
		];
	};
	readonly error: {
		readonly code: "error";
		readonly topics: readonly [
			"lethal"
		];
	};
	readonly apiError: {
		readonly code: "apiError";
		readonly topics: readonly [
			"lethal"
		];
	};
};
export declare type FieldValidationError = (typeof FieldValidationErrors)[keyof typeof FieldValidationErrors];
declare const FieldValidationErrors: {
	readonly cannotBeEmpty: "cannotBeEmpty";
	readonly dateOutOfRange: "dateOutOfRange";
	readonly format: "format";
	readonly lengthOutOfRange: "lengthOutOfRange";
};
export declare type FrameName = (typeof Frames)[number];
declare const Frames: readonly [
	"cardNumber",
	"cvv",
	"expDate",
	"holderName",
	"brandSelector",
	"birthDate"
];
export declare type GooglePayButtonOptions = Partial<Pick<ButtonOptions, "buttonColor" | "buttonType" | "buttonLocale" | "buttonRadius" | "buttonSizeMode">>;
export declare interface HostedFieldOptions {
	/**
	 * The ID of the container element where the iframe will be rendered.
	 */
	target: string;
	/**
	 * (Optional) Placeholder text for the input field.
	 */
	placeholder?: string;
	/**
	 * (Optional) ARIA label for accessibility.
	 */
	ariaLabel?: string;
}
export declare type HostedFieldsEventPayload = {
	fieldName: string;
	length: number;
	valid: boolean;
	touched: boolean;
	error: string;
};
export declare type HostedFieldsFormValues = {
	cardNumber: ManagedHostedFieldValue;
	cvv: ManagedHostedFieldValue;
	holderName: string;
	expDate: string;
	brandSelector: string;
	birthDate: string;
};
export declare type HostedFieldsInputVariantCssKeys = Pick<ThemeScope<"input">, "fontSize" | "fontWeight" | "color">;
/**
 * A theme is carrying all the style variables used for hosted fields.
 * global can be seen as a default values store on which the other scopes will rely on to fall back a value.
 *
 * @example
 * ```typescript
 * const exampleTheme: HostedFieldsTheme = {
 *  global: {
 *    fontSrc: 'https://fonts.googleapis.com/css?family=Roboto',
 *  },
 *  input: {
 *    color: '#333',
 *    fontSize: '16px',
 *    fontFamily: 'Arial, sans-serif',
 *    backgroundColor: '#fff',
 *    fontWeight: '400',
 *    ':valid': {
 *      color: 'green',
 *    },
 *    ':invalid': {
 *      color: 'red',
 *    },
 *    ':focus': {
 *      color: 'black',
 *    },
 *    '::placeholder': {
 *      color: '#aaa',
 *    }
 *  }
 * };
 * ```
 */
export declare type HostedFieldsTheme = {
	global: {
		/**
		 * This is used to set the font url.
		 * fontSrc is not a valid css style declaration key
		 */
		fontSrc?: string;
	};
	input: Pick<ThemeScope<"input">, "fontFamily" | "fontSize" | "fontWeight" | "color" | "backgroundColor"> & {
		":valid"?: HostedFieldsInputVariantCssKeys;
		":focus"?: HostedFieldsInputVariantCssKeys;
		":invalid"?: HostedFieldsInputVariantCssKeys;
		"::placeholder"?: HostedFieldsInputVariantCssKeys;
	};
};
export declare interface HostedFieldsUIOptions {
	/**
	 * Targets and labels for the all desired fields.
	 * The 'cvv' field is required; 'cardNumber' is optional.
	 */
	fields: {
		[ke in Exclude<FrameName, "cvv">]?: HostedFieldOptions;
	} & {
		cvv: HostedFieldOptions;
	};
}
/* Excluded from this release type: HostedFormTextKeys */
/**
 * Some partners displays a complete form and let you configure the text through a JS configuration. We've mapped those
 * texts and let you override all off them form this single object. During a session, while displaying a form some of
 * the variables might not be used, it depends on the context.
 */
declare interface HostedFormUIOptions {
	panPlaceholder?: string;
	panInputLabel?: string;
	panRequiredError?: string;
	panFormatError?: string;
	panCannotBeEmptyError?: string;
	panTooltipText?: string;
	birthdatePlaceholder?: string;
	birthdateInputLabel?: string;
	birthdateRequiredError?: string;
	birthdateFormatError?: string;
	birthdateCannotBeEmptyError?: string;
	birthdateOutOfRangeError?: string;
	cvvPlaceholder?: string;
	cvvInputLabel?: string;
	consentInputLabel?: string;
	consentRequiredError?: string;
	/**
	 * This value is interpolated with {url:string}
	 * use {{variable}} to use interpolation
	 * @example 'Your will agree to the <a href={{url}} target="_blank">tos</a> '
	 */
	consentText?: string;
	/**
	 * placeholder variant for cvv of length 4 (e.g. amex)
	 */
	cvv4Placeholder?: string;
	/**
	 * label variant for cvv of length 4 (e.g. amex)
	 */
	cvv4InputLabel?: string;
	cvvRequiredError?: string;
	cvvFormatError?: string;
	cvvCannotBeEmptyError?: string;
	cvvTooltipText?: string;
	expirationPlaceholder?: string;
	expirationInputLabel?: string;
	expirationRequiredError?: string;
	expirationFormatError?: string;
	expirationCannotBeEmptyError?: string;
	expirationOutOfRangeError?: string;
	expirationTooltipText?: string;
	holderPlaceholder?: string;
	holderInputLabel?: string;
	holderRequiredError?: string;
	holderFormatError?: string;
	holderCannotBeEmptyError?: string;
	ibanPlaceholder?: string;
	ibanInputLabel?: string;
	ibanRequiredError?: string;
	ibanFormatError?: string;
	ibanCannotBeEmptyError?: string;
	emailPlaceholder?: string;
	emailInputLabel?: string;
	emailRequiredError?: string;
	emailFormatError?: string;
	emailCannotBeEmptyError?: string;
	phonePlaceholder?: string;
	phoneInputLabel?: string;
	phoneRequiredError?: string;
	phoneFormatError?: string;
	phoneCannotBeEmptyError?: string;
	/**
	 * This value is interpolated with:
	 * - first
	 * - monthly
	 * - nb
	 * - total
	 * - cost
	 * - taeg
	 * use {{variable}} to use interpolation
	 */
	loanSimulation?: string;
	/**
	 * implicit - Select in pan input with logo
	 * explicit - Conventional select on top of the form
	 * hidden   - Hide the brand selector
	 */
	brandSelectionMode?: "implicit" | "explicit" | "hidden";
	explicitBrandText?: string;
	brandLabels?: {
		[key in CardScheme]?: string;
	};
}
declare const IntegrationTypes: {
	readonly hostedForm: "hostedForm";
	readonly hostedFields: "hostedFields";
	readonly xPayButton: "xPayButton";
	readonly redirection: "redirection";
};
export declare interface KRError {
	errorCode: string;
	errorMessage: string;
	detailedErrorCode?: string;
	detailedErrorMessage?: string;
	field?: string;
	children?: Array<KRError>;
	metadata?: Record<string, any>;
}
export declare type ManagedHostedFieldValue = "valid" | Extract<FieldValidationError, "cannotBeEmpty" | "format"> | null;
/**
 * Options let you override theme configuration and translations on our UIs.
 */
declare type Options = {
	/**
	 * Labels that can be found in a form
	 * {@link HostedFormUIOptions}
	 */
	[IntegrationTypes.hostedForm]?: HostedFormUIOptions;
	/**
	 * Transparent config toward XPay partners (e.g. GooglePay ApplePay ...)
	 * {@link XPayButtonUIOptions}
	 */
	[IntegrationTypes.xPayButton]?: XPayButtonUIOptions;
	/**
	 * Redirection config, used to override the title of the redirection
	 * {@link RedirectionUIOptions}
	 */
	[IntegrationTypes.redirection]?: RedirectionUIOptions;
	/**
	 * Hosted fields config, used to override the brand selector and the fields location
	 * {@link HostedFieldsUIOptions}
	 */
	[IntegrationTypes.hostedFields]?: HostedFieldsUIOptions;
	/**
	 * This section holds the style configuration. Matters like, font, colors, spacing can be override using this config.
	 * {@link PartnerUIOptionsTheme}
	 */
	theme?: PartnerUIOptionsTheme;
	/**
	 * Locale code is a combination of ISO 639-1 language code and ISO 3166-1 country code . For example, fr_FR is a locale code for French language in France.
	 * @example 'fr-FR'
	 */
	locale?: string;
};
/**
 * A theme is carrying all the style variables use across our UIs.
 * global can be seen as a default values store on which the other scopes will rely on to fall back a value.
 * @link PartnerUITheme
 *
 * @example
 * ```typescript
 *const exampleTheme: PartnerUITheme = {
 *  global: {
 *    color: '#222',
 *    fontSize: '16px',
 *    fontFamily: 'Arial, sans-serif',
 *    fontWeight: '400',
 *    gap: '8px',
 *    fontSrc: 'https://fonts.googleapis.com/css?family=Roboto',
 *    ':valid': {
 *      color: '#0a0',
 *    },
 *    ':invalid': {
 *      color: '#a00',
 *    },
 *  },
 *  input: {
 *    color: '#333',
 *    fontSize: '16px',
 *    fontFamily: 'Arial, sans-serif',
 *    borderRadius: '4px',
 *    backgroundColor: '#fff',
 *    borderColor: '#ccc',
 *    borderStyle: 'solid',
 *    borderWidth: '1px',
 *    fontWeight: '400',
 *    fontStyle: 'normal',
 *    padding: '8px',
 *    boxShadow: 'none',
 *    outlineColor: '#007bff',
 *    outlineStyle: 'solid',
 *    outlineWidth: '2px',
 *    ':hover': {
 *      borderColor: '#888',
 *    },
 *    ':focus': {
 *      borderColor: '#007bff',
 *      boxShadow: '0 0 0 2px #cce4ff',
 *    },
 *    '::placeholder': {
 *      color: '#aaa',
 *    },
 *    ':-webkit-autofill': {
 *      backgroundColor: '#eaffd0',
 *    },
 *  },
 *  label: {
 *    color: '#444',
 *    fontSize: '14px',
 *    fontFamily: 'Arial, sans-serif',
 *    fontWeight: '500',
 *    margin: '0 0 4px 0',
 *    ':valid': {
 *      color: '#0a0',
 *    },
 *    ':invalid': {
 *      color: '#a00',
 *    },
 *  },
 *  helperText: {
 *    color: '#888',
 *    fontSize: '12px',
 *    fontFamily: 'Arial, sans-serif',
 *    fontWeight: '400',
 *    margin: '4px 0 0 0',
 *    ':disabled': {
 *      color: '#ccc',
 *    },
 *    ':valid': {
 *      color: '#0a0',
 *    },
 *    ':invalid': {
 *      color: '#a00',
 *    },
 *  },
 *  tooltip: {
 *    color: '#fff',
 *    fontSize: '12px',
 *    fontFamily: 'Arial, sans-serif',
 *    fontWeight: '400',
 *    borderRadius: '4px',
 *    backgroundColor: '#222',
 *    padding: '8px',
 *    boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
 *    ':focus': {
 *      backgroundColor: '#333',
 *    },
 *    ':invalid': {
 *      backgroundColor: '#a00',
 *    },
 *  },
 *};
 * ```
 */
declare type PartnerUIOptionsTheme = DeepPartial<PartnerUITheme>;
declare type PartnerUITheme = {
	global: ThemeScope<"global"> & {
		/**
		 * This is passed down to eligible partners to set the font url.
		 * fontSrc is not a valid css style declaration key
		 */
		fontSrc?: string;
	};
	input: ThemeScope<"input">;
	label: ThemeScope<"label">;
	helperText: ThemeScope<"helperText">;
	tooltip: ThemeScope<"tooltip">;
};
export declare interface RedirectionUIOptions {
	title?: string;
}
export declare type Source = {
	type: "script" | "link";
	attributes: Record<string, string>;
};
declare const THEME_SCOPES: readonly [
	"global",
	"input",
	"label",
	"helperText",
	"tooltip"
];
declare const THEME_SCOPES_CSS_KEYS: {
	readonly global: readonly [
		"color",
		"fontSize",
		"fontFamily",
		"fontWeight",
		"gap"
	];
	readonly input: readonly [
		"color",
		"fontSize",
		"fontFamily",
		"borderRadius",
		"backgroundColor",
		"borderColor",
		"borderStyle",
		"borderWidth",
		"fontWeight",
		"fontStyle",
		"padding",
		"boxShadow",
		"outlineColor",
		"outlineStyle",
		"outlineWidth"
	];
	readonly helperText: readonly [
		"color",
		"fontSize",
		"fontFamily",
		"fontWeight",
		"margin"
	];
	readonly tooltip: readonly [
		"color",
		"fontSize",
		"fontFamily",
		"fontWeight",
		"borderRadius",
		"backgroundColor",
		"padding",
		"boxShadow"
	];
	readonly label: readonly [
		"color",
		"fontSize",
		"fontFamily",
		"fontWeight",
		"margin"
	];
};
declare const THEME_SCOPES_VARIANTS: {
	readonly global: readonly [
		":valid",
		":invalid"
	];
	readonly input: readonly [
		":hover",
		":valid",
		":focus",
		":invalid",
		"::placeholder",
		"::placeholder:disabled",
		":-webkit-autofill"
	];
	readonly helperText: readonly [
		":disabled",
		":valid",
		":invalid"
	];
	readonly tooltip: readonly [
		":focus",
		":invalid"
	];
	readonly label: readonly [
		":valid",
		":invalid"
	];
};
export declare type ThemeScope<Scope extends ThemeScopeName> = {
	[cssKey in ThemeScopeCSSKeys<Scope>]?: CSSStyleDeclaration[cssKey];
} & {
	[variant in ThemeScopesVariants<Scope>]?: {
		[cssKey in ThemeScopeCSSKeys<Scope>]?: CSSStyleDeclaration[cssKey];
	};
};
export declare type ThemeScopeCSSKeyMap = {
	[K in ThemeScopeName]: (typeof THEME_SCOPES_CSS_KEYS)[K][number];
};
export declare type ThemeScopeCSSKeys<S extends ThemeScopeName> = ThemeScopeCSSKeyMap[S];
export declare type ThemeScopeName = (typeof THEME_SCOPES)[number];
export declare type ThemeScopesVariants<Scope extends ThemeScopeName> = ThemeScopesVariantsMap[Scope];
export declare type ThemeScopesVariantsMap = {
	[K in ThemeScopeName]: (typeof THEME_SCOPES_VARIANTS)[K][number];
};
export declare interface UnifiedEventPayload {
	clientError: ErrorPayload | null;
	clientNotFound: ErrorPayload | null;
	died: ErrorPayload | null;
	apiError: Pick<ApiError, "error" | "additionalPayload" | "path"> | null;
	clientNotProperlyDestroyed: {
		error: string;
	};
	disconnected: null;
	environmentSet: Record<string, any> | null;
	fulfilled: {
		isFulfilled: boolean;
	};
	formDataChanged: {
		values: HostedFieldsFormValues;
		validationResult: Record<string, string>;
	};
	initFailed: ErrorPayload | null;
	cantDownloadPluginSources: ErrorPayload | null;
	loaded: Record<string, any> | null;
	misconfigured: string | null;
	modalIn: Record<string, any> | null;
	modalOut: Record<string, any> | null;
	optionsSet: Record<string, any> | null;
	pluginClientDestroyed: Record<string, any> | null;
	formStateChanged: Record<FrameName, string | null> & {
		errors?: AnyObject;
		active?: string;
	};
	pluginExtraSourcesLoaded: Record<string, any> | null;
	pluginIsIncompatibleWithInterface: {
		partner: Partner;
		method: Method;
		interface: string;
		fallBackInterface: string;
	};
	pluginIsIncompatibleWithClient: {
		partner: Partner;
		method: Method;
	};
	pluginPostValidation: Record<string, any> | null;
	pluginPreValidation: Record<string, any> | null;
	pluginSessionSet: Record<string, any> | null;
	pluginSourcesLoaded: Record<string, any> | null;
	ready: Record<string, any> | null;
	redirect: Record<string, any> | null;
	requestValidate: {
		skipOnBeforeValidate?: boolean;
	} | null;
	sourceListLoaded: {
		errors: Partial<Source>[] | false;
	} | null;
	sourceLoaded: {
		source: Partial<Source>;
		error: boolean;
	} | null;
	other: Record<string, any> | null;
	methodSelected: {
		method: string;
	};
	methodUnselected: {
		method: string;
	};
	partnerError: {
		error: Omit<KRError, "metadata">;
		method: string;
	};
	change: HostedFieldsEventPayload | null;
	focus: HostedFieldsEventPayload | null;
	blur: HostedFieldsEventPayload | null;
	keyup: HostedFieldsEventPayload | null;
	keydown: HostedFieldsEventPayload | null;
	error: {
		message: string;
	} | null;
	brandDetected: {
		brands: string[];
	} | null;
	supportedBrandsChanged: string[];
	selectedBrandChanged: string | null;
}
/**
 * Apple, Google and PayPal buttons are treated differently and all the config is exposed through this object.
 */
declare interface XPayButtonUIOptions {
	apple?: {
		type?: "plain" | "buy" | "donate" | "check-out" | "book" | "subscribe" | "add-money" | "contribute" | "order" | "reload" | "rent" | "support" | "tip" | "top-up";
		buttonstyle?: "black" | "white" | "white-outline";
		width?: string;
		height?: string;
		borderRadius?: string;
		padding?: string;
		/**
		 * Locale code is a combination of ISO 639-1 language code and ISO 3166-1 country code . For example, fr_FR is a locale code for French language in France.
		 * @example 'fr-FR'
		 */
		locale?: string;
	};
	google?: GooglePayButtonOptions;
	paypal?: {
		layout?: "vertical" | "horizontal";
		color?: "silver" | "white" | "black" | "gold" | "blue";
		shape?: "rect" | "pill";
		height?: number;
		label?: "paypal" | "checkout" | "buynow" | "pay" | "installment";
	};
}
/**
 * Interface for managing and interacting with a payment partner's UI component.
 * Provides methods to render, configure, and handle events from payment UIs like credit card forms or digital wallet buttons.
 *
 * @example
 * ```typescript
 * // Get a payment element from a payment method
 * const paymentElement = method.getPaymentElement();
 *
 * // Configure the UI See {@link Options}
 * paymentElement.setOptions({
 *   hostedForm: {
 *     panPlaceholder: 'Enter your card number',
 *     cvvPlaceholder: 'Enter your CVV'
 *     // Add more options here
 *   },
 *   theme:{
 *     global:{
 *        fontSize: "12px"
 *     }
 *   }
 * });
 *
 * // Render the UI
 * paymentElement.appendTo('#payment-form');
 *
 * // Listen for events
 * paymentElement.on('formValid', () => {
 *   console.log('Payment UI form is valid');
 * });
 * ```
 */
export interface PurseHeadlessCheckoutPaymentElement {
	/**
	 * Configures the appearance and behavior of the payment UI.
	 * Use this to customize the look and feel of the payment form to match your application's design.
	 *
	 * @param options - Configuration options for the payment UI
	 *                 See {@link Options} for available customization options
	 * @example
	 * ```typescript
	 * paymentElement.setOptions({
	 *   hostedForm: {
	 *     panPlaceholder: 'Enter your card number',
	 *     cvvPlaceholder: 'Enter your CVV'
	 *     // Add more options here
	 *   }
	 * });
	 * ```
	 */
	setOptions(options?: Options): void;
	/**
	 * Renders the payment UI into the specified container element.
	 * The container can be either a CSS selector string or a direct reference to an HTML element.
	 *
	 * @param container - CSS selector (e.g., '#payment-form') or HTML element to render the UI into
	 * @throws {Error} If the container element cannot be found or is invalid
	 * @example
	 * ```typescript
	 * // Using a CSS selector
	 * paymentElement.appendTo('#payment-form');
	 *
	 * // Using an HTML element
	 * const container = document.getElementById('payment-form');
	 * paymentElement.appendTo(container);
	 * ```
	 */
	appendTo(container: string | Element): void;
	/**
	 * Checks if the payment partner provides a visual UI component.
	 * Use this to determine if you need to allocate space in your layout for the payment UI.
	 * Some payment methods (like redirect-based flows) might not have a UI component.
	 *
	 * @returns true if the payment method has a UI component to display, false otherwise
	 * @example
	 * ```typescript
	 * if (paymentElement.hasUI()) {
	 *   // Add conditional styles or layout adjustments
	 *   // based on the presence of a payment UI
	 * }
	 * ```
	 */
	hasUI(): boolean;
	/**
	 * Force the payment UI to validate the form fields.
	 * For credit cards, this checks if all required fields are filled and valid.
	 * For other payment methods, this verifies if the UI is in a valid state for submission.
	 *
	 * @returns A promise that resolves to:
	 *          - boolean: true if validation passed, false if failed
	 *          - CreditCardValidateUiResult: detailed validation results for credit card forms
	 * @example
	 * ```typescript
	 * const isValid = await paymentElement.validateUi();
	 * if (isValid) {
	 *   // show success message
	 *   console.log('Payment form is valid');
	 * } else {
	 *  // show error message
	 *  console.error('Payment form is invalid');
	 * }
	 * ```
	 */
	validateUi(): Promise<boolean | CreditCardValidateUiResult>;
	/**
	 * Removes the payment UI from the DOM and cleans up any associated resources.
	 * Call this when the payment UI is no longer needed or when switching payment methods.
	 *
	 * @example
	 * ```typescript
	 * // Clean up the payment UI when switching methods
	 * paymentElement.remove();
	 * ```
	 */
	remove(): void;
	/**
	 * Registers an event listener for payment UI events.
	 * Listen for events like 'ready', 'change', 'blur', 'focus', etc.
	 *
	 * @param {PaymentElementEventName} eventName - Name of the event to listen for
	 * @param callback - Function to be called when the event occurs
	 * @example
	 * ```typescript
	 * // Listen for the UI ready event
	 * paymentElement.on('formValid', () => {
	 *   console.log('Payment UI form is valid');
	 * });
	 * ```
	 */
	on<K extends PaymentElementEventName>(eventName: K, callback: PaymentElementEventsCallback[K]): void;
}
export interface PurseHeadlessCheckoutHostedFields extends Omit<PurseHeadlessCheckoutPaymentElement, "appendTo"> {
	supportedBrands: Readable<CardScheme[]>;
	detectedBrands: Readable<CardScheme[]>;
	selectedBrand: Readable<CardScheme | null>;
	/**
	 * When the card is "co-branded" the user is allowed to set the selected brand.
	 * @param brand - The brand to set as selected
	 * @example
	 * ```typescript
	 * // Set the selected brand to "VISA"
	 * hostedFields.setSelectedBrand('VISA');
	 * ```
	 * @throws {@link PurseHeadlessCheckoutError} `NOT_SUPPORTED_BRAND` when the provided brand is not in the supported brands list.
	 * @throws {@link PurseHeadlessCheckoutError} `BRAND_NOT_BELONGS_TO_DETECTED` when brands are detected and the provided brand is not in the detected list.
	 */
	setSelectedBrand(brand: CardScheme): void;
	/**
	 * Renders the payment UI into the specified container element.
	 * The container can be either a CSS selector string or a direct reference to an HTML element.
	 *
	 * @example
	 * ```typescript
	 * // Using a CSS selector
	 * hostedFields.render();
	 * ```
	 */
	render(): void;
}
export interface PurseHeadlessCheckoutSecondaryTokenProvider {
	/**
	 * @param pan
	 * @param cvv
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `FAILED_TO_ADD_TOKEN` \
	 * If secondary token creation fails
	 * - {@link PurseHeadlessCheckoutError} `FAILED_TO_INIT_SECONDARY_TOKEN` \
	 * If secondary token initialization fails
	 * - {@link PurseHeadlessCheckoutError} `MISSING_SESSION` \
	 * If the session is missing
	 * - {@link PurseHeadlessCheckoutError} `PAYMENT_METHOD_NOT_FOUND` \
	 * If the partner and method associated to the token could not be found in the ones available in the session
	 * - {@link PurseHeadlessCheckoutError} `SECONDARY_METHOD_REQUIRED_CVV` \
	 * If the cvv is missing
	 * - {@link PurseHeadlessCheckoutError} `SECONDARY_METHOD_WRONG_PAN_FORMAT` \
	 * If the provided pan does not respect the expected format
	 * - {@link PurseHeadlessCheckoutError} `SECONDARY_METHOD_WRONG_CVV_FORMAT` \
	 * If the provided cvv does not respect the expected format
	 */
	getSecondaryToken(pan: string, cvv?: string): Promise<PurseHeadlessCheckoutTemporarySecondaryToken>;
}
export type PaymentElementEventName = "fatalError" | "formValid" | "validationRequested" | "methodSelected" | "methodUnselected" | "change" | "focus" | "modalIn" | "modalOut" | "blur" | "ready" | "keyup" | "keydown" | "partnerError";
export interface PaymentElementEventsPayload {
	fatalError: {
		code: string;
		reason: string;
		internalEventCode: EventCode;
	};
	formValid: {
		isValid: boolean;
	};
	validationRequested: UnifiedEventPayload["requestValidate"];
	methodSelected: UnifiedEventPayload["methodSelected"];
	methodUnselected: UnifiedEventPayload["methodUnselected"];
	partnerError: UnifiedEventPayload["partnerError"];
	change: UnifiedEventPayload["change"];
	focus: UnifiedEventPayload["focus"];
	blur: UnifiedEventPayload["blur"];
	modalIn: UnifiedEventPayload["modalIn"];
	modalOut: UnifiedEventPayload["modalOut"];
	ready: UnifiedEventPayload["ready"];
	keyup: UnifiedEventPayload["keyup"];
	keydown: UnifiedEventPayload["keydown"];
}
export interface PaymentElementEventsCallback {
	/** Handler for fatal error events */
	fatalError: (payload: PaymentElementEventsPayload["fatalError"]) => void;
	/** Handler for form validation success events */
	formValid: (payload: PaymentElementEventsPayload["formValid"]) => void;
	/** Handler for validation request events */
	validationRequested: (payload: PaymentElementEventsPayload["validationRequested"]) => void;
	/** Handler for method selected events */
	methodSelected: (payload: PaymentElementEventsPayload["methodSelected"]) => void;
	/** Handler for method unselected events */
	methodUnselected: (payload: PaymentElementEventsPayload["methodUnselected"]) => void;
	/** Handler for partner error events */
	partnerError: (payload: PaymentElementEventsPayload["partnerError"]) => void;
	change: (payload: PaymentElementEventsPayload["change"]) => void;
	focus: (payload: PaymentElementEventsPayload["focus"]) => void;
	blur: (payload: PaymentElementEventsPayload["blur"]) => void;
	ready: (payload: PaymentElementEventsPayload["ready"]) => void;
	keyup: (payload: PaymentElementEventsPayload["keyup"]) => void;
	modalIn: (payload: PaymentElementEventsPayload["modalIn"]) => void;
	modalOut: (payload: PaymentElementEventsPayload["modalOut"]) => void;
	keydown: (payload: PaymentElementEventsPayload["keydown"]) => void;
}
export type SecondaryTakePolicy = "none" | "max";
/**
 * Secondaries are true Headless payment methods and are handled directly by the SDK for now.
 * They are not handled by the partner UI.
 */
export interface SecondarySpecificConfig {
	/**
	 * Does this method require a CVV?
	 */
	requiresCVV: (pan: string) => boolean;
	/**
	 * Validates the pan of the card.
	 */
	validatePan: (pan: string) => boolean;
	/**
	 * Validates the pan of the card.
	 */
	validateCVV?: (cvv: string) => boolean;
	/**
	 * Take policy
	 */
	takePolicy: SecondaryTakePolicy;
	/**
	 * Map the method data to the payload.
	 */
	mapPaymentData?: (item: SecondaryPluginInitPayload, pan: string, cvv?: string) => SecondaryPluginInitPayload;
}
/**
 * An amount can be covered by single or multiple payment split.
 */
export interface PaymentSplit {
	amount: number;
	source: PurseHeadlessCheckoutPaymentItem;
}
export interface PaymentSplitter {
	/**
	 * Total amount to be paid in cents
	 */
	amount: Readable<number>;
	/**
	 * The amount that is not covered by the splits.
	 */
	primaryReach: Readable<number>;
	/**
	 * The list of splits.
	 * @see {PaymentSplit}
	 */
	splits: Readable<PaymentSplit[]>;
	/**
	 * This reactive value switches to true when the splits cover the total amount.
	 */
	fulfilled: Readable<boolean>;
	/**
	 * Given a mean of payment, returns the amount that it can cover as a reactive value.
	 * @param mop { MeanOfPayment}
	 */
	getMeanOfPaymentReach(mop: PurseHeadlessCheckoutPaymentItemBase): Readable<number>;
	/**
	 * Set the primary split. If a splitting can use multiple secondary means of payment, it can only use one primary at a time.
	 * @param mop { MeanOfPayment}
	 */
	setPrimary(mop: PurseHeadlessCheckoutPaymentItem | null): void;
	/**
	 * Involves a secondary mean of payment in the split.
	 * Secondary methods can yield multiple means of payment that can be used with different amounts.
	 * @param amount in cents. Set to 0 to remove the split.
	 * @param mop { MeanOfPayment}
	 */
	takeSplit(amount: number, mop: PurseHeadlessCheckoutPaymentItem): void;
	/**
	 * Removes the split from MOP if it exists.
	 * @param mop { MeanOfPayment}
	 */
	clearSplit(mop: PurseHeadlessCheckoutPaymentItem): void;
	/**
	 * Resets splits and change amount
	 * @param amount in cts
	 */
	reset(amount: number): void;
	isMethodLimitReached(mop: PurseHeadlessCheckoutPaymentItem): boolean;
}
export type PurseHeadlessCheckoutV1SessionData = LegacyPaymentSession;
/**
 * Interface representing a V1 session for the Headless Checkout.
 */
export interface PurseHeadlessCheckoutV1Params {
	/** API key for authentication */
	apiKey: string;
	/** Unique identifier for the merchant entity */
	entityId: string;
	/** Target environment for the checkout (e.g., 'sandbox', 'production') */
	environment: EnvironmentTarget;
	/** Payment session data containing transaction details */
	paymentSession: PurseHeadlessCheckoutV1SessionData;
}
/**
 * Represents a V2 session for the Headless Checkout.
 *
 * This string contains encoded session information.
 * It is used to initialize and manage a V2 payment session.
 *
 * @typedef {string} PurseHeadlessCheckoutV2Params
 * @group Interfaces
 */
export type PurseHeadlessCheckoutV2Params = string;
export type RedirectionBasicParams = {
	type: "redirection";
	url: string;
};
export type RedirectionJSONParams = {
	type: "jsonFormSubmit";
	url: string;
	JSONPayload?: string;
	method?: "GET" | "POST";
};
export type RedirectionHTMLParams = {
	type: "htmlFormSubmit";
	containerId: string;
	responseForm: any;
};
export type RedirectionHandlerParams = RedirectionBasicParams | RedirectionJSONParams | RedirectionHTMLParams;
export interface PurseHeadlessCheckoutHooks {
	/** Optional argument to pass a callback to invoke before submission */
	onBeforeValidate?: (split: PaymentSplit[]) => Promise<void>;
	/** Optional argument to pass a callback to invoke after submission */
	onAfterValidate?: () => Promise<void>;
	/** Optional argument to handle the redirection */
	redirectionHandler?: (redirectionData: RedirectionHandlerParams) => Promise<void>;
}
/**
 * Enumeration of possible disabled state codes for payment methods.
 */
export type DisabledStateCode = "METHOD_UNSTABLE" | "TOKEN_INIT_FAILED" | "PAYMENT_ELEMENT_FATAL_ERROR" | "SUBMITTING" | "PAYMENT_ELEMENT_RENDER_FAILED" | "PARTNER_UI_FATAL_ERROR" | "MIN_AMOUNT_NOT_MET" | "DOES_NOT_BELONG_TO_CURRENT_SESSION" | "MAX_AMOUNT_EXCEEDED";
/**
 * Represents the disabled state of a payment method.
 * @property code - {@link DisabledStateCode} The code indicating the reason for the disabled state.
 * @property message - A human-readable message providing more details about the disabled state.
 */
export type DisabledState = {
	code: DisabledStateCode;
	message: string;
};
export type PurseHeadlessCheckoutSessionState = "idle" | "ready" | "submitting" | "submitted" | "error" | "expired";
/**
 * Represents a payment split configuration where multiple payment sources can be combined to fulfill the total payment amount.
 * The sum of all splits must equal the total payment amount.
 */
export interface PurseHeadlessCheckoutPaymentSplit {
	source: PurseHeadlessCheckoutPaymentItem;
	amount: number;
}
/**
 * Base interface for all payment items in the Purse checkout system.
 * Provides common properties shared between payment methods and tokens.
 *
 * @remarks
 * This interface should not be used directly in your application code.
 * Instead, use {@link PurseHeadlessCheckoutMethod} or {@link PurseHeadlessCheckoutToken}.
 */
export interface PurseHeadlessCheckoutPaymentItemBase {
	/** Unique identifier of the payment method
	 * @example 'hipay-bancontact'
	 * @example 'illicado-giftcard'
	 * @example 'aci-creditcard'
	 *
	 */
	id: string;
	/** Partner associated with the payment method
	 * @example 'hipay'
	 * @example 'paypal'
	 */
	partner: string;
	/** Type of payment method, it can be a card, a wallet, a bank transfer, etc.
	 * @example 'applepay'
	 * @example 'googlepay'
	 * @example 'creditcard'
	 */
	method: string;
	type: "method" | "token" | "temporary_token" | undefined;
	/** Indicates if the payment method is a secondary mean of payment */
	isSecondary: boolean;
	/** Minimum amount to use the payment method */
	minAmount: number | null;
	/** Maximum amount to use the payment method */
	maxAmount: number | null;
}
/**
 * Represents an available payment method in the Purse checkout system.
 * Payment methods can be primary (e.g., credit cards, digital wallets) or secondary (e.g., gift cards).
 */
export interface PurseHeadlessCheckoutMethod extends PurseHeadlessCheckoutPaymentItemBase {
	type: "method";
	/**
	 * Indicates if the payment method is disabled with an error code and message
	 * {@link DisabledState} error code and message
	 */
	disabled: Writable<DisabledState | null>;
	/** Position of the payment method in the list */
	position: number;
	/** Amount limit for the payment method (null if no limit) */
	limit: number | null;
}
/**
 * Represents a saved payment token in the Purse checkout system.
 * Tokens are secure references to saved payment methods like stored credit cards or digital wallet accounts.
 * @example
 * ```typescript
 * // Assume `token` is an instance of PurseHeadlessCheckoutToken
 * // Edit token name
 * await token.edit({ name: 'Personal Card' });
 *
 * // Delete token
 * await token.delete();
 * ```
 */
export interface PurseHeadlessCheckoutToken extends PurseHeadlessCheckoutPaymentItemBase, PurseHeadlessCheckoutEditable {
	name: string;
	type: "token" | "temporary_token";
	/**
	 * Indicates if the payment token is disabled with an error code and message
	 */
	disabled: Readable<DisabledState | null>;
}
/**
 * HostedFieldsOptions let you override theme configuration, render targets and placeholders for hosted fields.
 * @see {@link Options.locale} for locale configuration
 */
export type HostedFieldsOptions = Pick<Options, "locale"> & HostedFieldsUIOptions & {
	/**
	 * This section holds the theme configuration. Matters like, font, colors, spacing can be override using this config.
	 * {@link HostedFieldsTheme}
	 */
	theme: HostedFieldsTheme;
};
/**
 * PaymentElementOptions let you override theme configuration and placeholders for hosted forms.
 * {@link Options}
 */
export type PaymentElementOptions = Omit<Options, "hostedFields">;
/**
 * Represents a primary payment method in the Purse checkout system.
 * Primary methods are the main payment options like credit cards, digital wallets, or bank transfers.
 *
 * @example
 * ```typescript
 * // Get payment element for a primary method
 * const primaryMethod: PurseHeadlessCheckoutPrimaryMethod = ...
 * const element = await primaryMethod.getPaymentElement({
 *   hostedForm: {
 *     panPlaceholder: 'Enter your card number',
 *     cvvPlaceholder: 'Enter your CVV'
 *     // Add more options here
 *   }
 * });
 *
 * // Mount the payment element to your UI
 * element.appendTo('#payment-container');
 * ```
 */
export interface PurseHeadlessCheckoutPrimaryMethod extends PurseHeadlessCheckoutMethod, PurseHeadlessCheckoutRegisterable {
	isSecondary: false;
	/** Whether the method can provide loan simulation or not*/
	simulable: boolean;
	/**
	 * Creates and returns a payment element UI instance for this payment method.
	 * The instance is created only on the first call and cached for subsequent calls.
	 *
	 * @param options - Optional UI customization settings for the payment element
	 * @returns A payment element instance for this payment method
	 * @example
	 * ```typescript
	 * const paymentElement = primaryMethod.getPaymentElement({
	 *   hostedForm: {
	 *     panPlaceholder: 'Enter your card number',
	 *     cvvPlaceholder: 'Enter your CVV'
	 *     // Add more options here
	 *   }
	 * })
	 * await paymentElement.appendTo('#payment-container');
	 * ```
	 */
	getPaymentElement(options?: PaymentElementOptions): PurseHeadlessCheckoutPaymentElement;
	/**
	 * Creates and returns a hosted fields UI instance for this payment method.
	 * @param options {@link HostedFieldsOptions}: settings for the hosted fields
	 * @return A hosted fields instance for this payment method
	 * @example
	 * ```typescript
	 *   const hostedFields = primaryMethod.getHostedFields({
	 *      fields: {
	 *        pan: {
	 *          target: '#card-number',
	 *          placeholder: 'Card number',
	 *        },
	 *        cvv: {
	 *          target: '#card-cvv',
	 *          placeholder: 'CVV',
	 *        },
	 *        expirationDate: {
	 *          target: '#card-expiration-date',
	 *          placeholder: 'MM / YY',
	 *        },
	 *      },
	 *      theme: {
	 *        global: {
	 *          fontSrc: 'https://fonts.googleapis.com/css?family=Roboto',
	 *        },
	 *        input: {
	 *          color: '#333',
	 *          fontSize: '16px',
	 *          fontFamily: 'Arial, sans-serif',
	 *          backgroundColor: '#fff',
	 *          fontWeight: '400',
	 *          ':valid': {
	 *            color: 'green',
	 *          },
	 *        }
	 *      }
	 *    });
	 *   await hostedFields.render();
	 * ```
	 */
	getHostedFields(options?: HostedFieldsOptions): PurseHeadlessCheckoutHostedFields;
	/**
	 * Changes the active primary payment source in the current payment split.
	 * Use this when you have multiple primary payment elements mounted (e.g., Wallet AND installments).
	 *
	 * @throws - {@link PurseHeadlessCheckoutError} `code: "ELEMENT_NOT_FULFILLED"` \
	 * If the method has empty or incomplete payment information
	 *
	 * @example
	 * ```typescript
	 * // Switch to this payment method as the primary source
	 * await method.setAsPrimarySource();
	 * ```
	 */
	setAsPrimarySource(): void;
	/**
	 * Some method are 'simulable' and can give a loan simulation if provided with a product description
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `INVALID_LOAN_SIMULATION` \
	 * If the method is not simulable or when an error happened during the simulation.
	 *
	 * @example
	 * ```typescript
	 * await method.simulateLoan({ amount: 200, shipments: [], currency_code: 'EUR',...  });
	 * ```
	 */
	simulateLoan(product: LoanProduct): Promise<LoanSimulation>;
	/**
	 * Some partners are available under several forms
	 * For instance paypal or klarna can exist as a redirection or as a popup
	 */
	integrationType?: "redirection" | "popup";
}
export interface PurseHeadlessCheckoutCreditcardMethod extends PurseHeadlessCheckoutPrimaryMethod {
	/**
	 * Brand supported by the method when a creditcard is involved.
	 */
	supportedBrands: CardScheme[];
}
/**
 * Represents a secondary payment method in the Purse checkout system.
 * Secondary methods are additional payment options like gift cards that can be combined with primary methods.
 */
export type PurseHeadlessCheckoutSecondaryMethod = PurseHeadlessCheckoutMethod & PurseHeadlessCheckoutSecondaryTokenProvider & {
	type: "method";
	/** Maximum instances of this secondary method that can be used in the split */
	limit?: number;
	/** Always true for secondary payment methods */
	isSecondary: true;
} & SecondarySpecificConfig;
/**
 * Represents a primary token in the Purse checkout system.
 * Primary tokens are saved payment methods like stored credit cards or digital wallet accounts.
 */
export interface PurseHeadlessCheckoutPrimaryToken extends PurseHeadlessCheckoutToken {
	type: "token";
	/** Indicates if the token is a secondary mean of payment */
	isSecondary: false;
	/**
	 * Description holds all display values to describe the token in a UI. This is useful since the rendering of a token
	 * is limited to the CVV.
	 */
	description: {
		/**
		 * Label is optional, the user have not necessarily given a label to the token when creating it.
		 */
		label?: string;
		/**
		 * Brand of the token
		 */
		brand?: string;
		/**
		 * Holder name of the token
		 */
		holderName?: string;
		/**
		 * Will contain displayable value of the PAN or the account email
		 */
		masked_pan: string;
		/**
		 * Date at which the token is excepted to expire
		 */
		expiration_date: string;
	};
	/**
	 * Method to get the payment element. Creates the UI instance on first call.
	 * If you need to render a partner's UI, you will need a PaymentElement
	 * @param options {Options | undefined}
	 * @return {PurseHeadlessCheckoutPaymentElement}
	 * @example
	 * ```typescript
	 * const paymentElement = token.getPaymentElement();
	 * // Mount the payment element to your UI
	 * paymentElement.appendTo('#payment-container');
	 * ```
	 * */
	getPaymentElement(options?: Options): PurseHeadlessCheckoutPaymentElement;
	/**
	 * Creates and returns a hosted fields UI instance for this payment method.
	 * @param options {@link HostedFieldsOptions}: settings for the hosted fields
	 * @return A hosted fields instance for this payment method
	 * @example
	 * ```typescript
	 *   const hostedFields = primaryMethod.getHostedFields({
	 *      fields: {
	 *        cvv: {
	 *          target: '#card-cvv',
	 *          placeholder: 'CVV',
	 *        },
	 *      },
	 *      theme: {
	 *        global: {
	 *          fontSrc: 'https://fonts.googleapis.com/css?family=Roboto',
	 *        },
	 *        input: {
	 *          color: '#333',
	 *          fontSize: '16px',
	 *          fontFamily: 'Arial, sans-serif',
	 *          backgroundColor: '#fff',
	 *          fontWeight: '400',
	 *          ':valid': {
	 *            color: 'green',
	 *          },
	 *        }
	 *      }
	 *    });
	 *   await hostedFields.render();
	 * ```
	 */
	getHostedFields(options?: HostedFieldsOptions): PurseHeadlessCheckoutHostedFields;
	/** Use this method if you want to change which primary to use in the split.
	 * This can be useful if you have mounted multiple primary payment elements (ie. Wallet AND installments for
	 * instance).
	 *
	 * @throws - {@link PurseHeadlessCheckoutError} `ELEMENT_NOT_FULFILLED` \
	 * If the token has empty or incomplete payment information
	 *
	 * @example
	 * ```typescript
	 * token.setAsPrimarySource();
	 * ```
	 */
	setAsPrimarySource(): void;
	/**
	 * @internal
	 * this is useful for completing the payment
	 */
	value: string;
}
/**
 * Represents a secondary token in the Purse checkout system.
 * Secondary tokens are saved alternative payment methods like gift cards that can be combined with primary payment methods.
 *
 * @example
 * ```typescript
 * // Use part of the gift card balance
 * await secondaryToken.take(50);
 *
 * // Remove it from the split if needed
 * await secondaryToken.removeFromSplit();
 * ```
 */
export interface PurseHeadlessCheckoutSecondaryToken extends PurseHeadlessCheckoutToken {
	type: "token" | "temporary_token";
	isSecondary: true;
	limit: number;
	expiration_date: string | Date;
	/**
	 * The amount available for use on the card.
	 * This value will be at 0 until we've fetched its current value.
	 * The fetching is done in parallel during the checkout creation to speed up the process.
	 */
	balance: Readable<number>;
	/**
	 * the card pan
	 */
	pan: string;
	/**
	 * the card cvv
	 */
	cvv?: string;
	/**
	 * Depending on the secondary method, the takable amount is constrained. Vouchers for instance can't be partially used.
	 * | method                | take policy |
	 * |-----------------------|-------------|
	 * | easy2play - voucher   | max         |
	 * | easy2play - giftcard  | none        |
	 * | illicado - giftcard   | none        |
	 * | ogloba - giftcard     | none        |
	 * | buybox - giftcard     | none        |
	 * | maxxing - loyaltycard | max         |
	 *
	 * Max: "All or nothing" the only takable amount is the full balance.
	 * None: The take amount is not constrained (should still be less than the token's available balance').
	 */
	takePolicy: SecondaryTakePolicy;
	/**
	 * Applies a specified amount from this secondary token to the current payment session.
	 * The amount will be deducted from the token's balance and added to the payment split.
	 *
	 * @param amount - Amount to use from this token's balance
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `INVALID_TAKE_AMOUNT` \
	 * If any of these conditions are not met:
	 *    - Amount must be greater than 0
	 *    - Amount must be less than the remaining session amount
	 *    - Amount must be less than the token's available balance
	 * - {@link PurseHeadlessCheckoutError} `METHOD_NOT_IMPLEMENTED` \
	 * If the real token could not be fetched and a placeholder object was returned instead
	 * - {@link PurseHeadlessCheckoutError} `USAGE_LIMIT_ERROR` \
	 * If the usage limit of the secondary method was reached
	 * - {@link PurseHeadlessCheckoutError} `SECONDARY_METHOD_TAKE_POLICY_VIOLATED` \
	 * If the take amount requested violates the policy of the secondary method.
	 *
	 * @example
	 * ```typescript
	 * // Use 50 from a gift card balance
	 * await token.take(50);
	 * ```
	 */
	take(amount: number): Promise<void>;
	/**
	 * Removes this token from the current payment split configuration.
	 * Any amount previously allocated from this token will be removed from the split.
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `METHOD_NOT_IMPLEMENTED` \
	 * If the real token could not be fetched and a placeholder object was returned instead
	 *
	 * @example
	 * ```typescript
	 * // Remove a gift card from the payment split
	 * await token.removeFromSplit();
	 * ```
	 */
	removeFromSplit(): Promise<void>;
}
export interface PurseHeadlessCheckoutTemporarySecondaryToken extends PurseHeadlessCheckoutSecondaryToken, PurseHeadlessCheckoutRegisterable {
	type: "temporary_token";
}
export type RegistrationState = {
	registered: boolean;
	name: string | null;
};
export interface PurseHeadlessCheckoutRegisterable {
	/**
	 * Mark this mean of payment for registration upon validate.
	 * @param value {boolean} true to register, false to unregister
	 * @param params
	 * @example
	 * ```typescript
	 * item.register(true);
	 * ```
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `INVALID_TOKEN_NAME` \
	 * If the provided token name is invalid
	 * - {@link PurseHeadlessCheckoutError} `TOKEN_NOT_REGISTERABLE` \
	 * If the token is not registerable
	 */
	register(value?: boolean, params?: {
		name?: string;
	}): Promise<void>;
	/**
	 * This property exposes the saveToken configuration of the method.
	 * A mean of payment cannot be saved if the method is not registerable.
	 */
	canBeRegistered: boolean;
	/**
	 * This property exposes if the mean of payment is bound for registration upon validate.
	 */
	registration: Readable<RegistrationState>;
}
export interface PurseHeadlessCheckoutEditable {
	/**
	 * Delete the token from the user's wallet
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `METHOD_NOT_IMPLEMENTED` \
	 * If the token is of type {@link PurseHeadlessCheckoutTemporarySecondaryToken}
	 * - {@link PurseHeadlessCheckoutError} `MISSING_SESSION` \
	 * If the session is missing
	 * - {@link PurseHeadlessCheckoutError} `MISSING_TOKEN` \
	 * If the provided token cannot be found
	 * - {@link PurseHeadlessCheckoutError} `MISSING_WALLET_SESSION` \
	 * If the wallet session is missing
	 * - {@link PurseHeadlessCheckoutError} `UNKNOWN_ERROR` \
	 * If an unknown error is caught during the deletion
	 *
	 * @example
	 * ```typescript
	 * token.delete();
	 * ```
	 */
	delete(): Promise<void>;
	/**
	 * Edit the token's name
	 * @param payload
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `TOKEN_NOT_REGISTERABLE` \
	 * If the token is not registerable
	 * - {@link PurseHeadlessCheckoutError} `TOKEN_NOT_REGISTERED` \
	 * If the token is not registered (see {@link PurseHeadlessCheckoutRegisterable.register})
	 * - {@link PurseHeadlessCheckoutError} `TOKEN_NAME_EXISTS` \
	 * If the token name already exists
	 * - {@link PurseHeadlessCheckoutError} `MISSING_TOKEN` \
	 * If the provided token cannot be found
	 * - {@link PurseHeadlessCheckoutError} `INVALID_TOKEN_NAME` \
	 * If the provided token name is invalid
	 * - {@link PurseHeadlessCheckoutError} `MISSING_WALLET_SESSION` \
	 * If the wallet session is missing
	 *
	 * @example
	 * ```typescript
	 * token.edit({ name: 'New Name' });
	 * ```
	 */
	edit(payload: {
		name: string;
	}): Promise<void>;
}
export type PurseHeadlessCheckoutPaymentMethod = PurseHeadlessCheckoutSecondaryMethod | PurseHeadlessCheckoutPrimaryMethod;
export type PurseHeadlessCheckoutPaymentToken = PurseHeadlessCheckoutSecondaryToken | PurseHeadlessCheckoutPrimaryToken | PurseHeadlessCheckoutTemporarySecondaryToken;
export type PurseHeadlessCheckoutPaymentItem = PurseHeadlessCheckoutPaymentMethod | PurseHeadlessCheckoutPaymentToken;
export interface HeadlessCheckout {
	/**
	 * Current paymentSessionID readable value;
	 */
	readonly currentSessionID: Readable<string | null>;
	/**
	 * List of available payment methods for the checkout.
	 * This property is a Writable object containing an array of PurseCheckoutPaymentMethod.
	 * Each payment-element in the array represents a payment method with its associated properties.
	 * @type {Readable<Array<PurseHeadlessCheckoutPaymentMethod>>}
	 * @example
	 * ```ts
	 * headlessCheckout.paymentMethods.subscribe((methods: PurseCheckoutPaymentMethod[]) => {
	 *    console.log('The payment methods changed', methods);
	 *    // Perhaps update the UI with the new methods
	 * });
	 * ```
	 */
	readonly paymentMethods: Writable<PurseHeadlessCheckoutPaymentMethod[]>;
	/**
	 * List of available payment tokens for the checkout.
	 * This property is a Writable object containing an array of PurseCheckoutPaymentToken.
	 * Each payment-element in the array represents a payment token with its associated properties.
	 * @type {Readable<Array<PurseCheckoutPaymentToken>>}
	 * @example
	 * ```ts
	 * headlessCheckout.paymentTokens.subscribe((tokens: PurseCheckoutPaymentToken[]) => {
	 *   console.log('The payment tokens changed', tokens);
	 *   // Perhaps update the UI with the new tokens
	 * });
	 * ```
	 */
	readonly paymentTokens: Writable<PurseHeadlessCheckoutPaymentToken[]>;
	/**
	 * This property indicates if the payment can be submitted.
	 * @example
	 * ```ts
	 * headlessCheckout.isPaymentFulfilled.subscribe((isFulfilled: boolean) => {
	 *    if(isFulfilled) {
	 *      enablePayButton();
	 *    }else{
	 *      disablePayButton();
	 *    }
	 * });
	 * ```
	 */
	readonly isPaymentFulfilled: Readable<boolean>;
	/**
	 * The remaining amount to pay represents the amount that is left to pay after the secondary payment method(s) has been used.
	 * @example
	 * ```ts
	 * headlessCheckout.remainingAmountToPay.subscribe((amount: number) => {
	 *    console.log('Perhaps update the text in your pay button', amount);
	 * });
	 * ```
	 * */
	remainingAmountToPay: Readable<number>;
	/**
	 * Splits represent the repartition between the primary payment method and the secondary payment methods.
	 * @link PurseHeadlessCheckoutPaymentSplit
	 * @example
	 * ```ts
	 * headlessCheckout.amountSplit.subscribe((splits: PurseHeadlessCheckoutPaymentSplit[]) => {
	 *    console.log('The payment composition changed', splits);
	 * });
	 * ```
	 * */
	amountSplit: Readable<PurseHeadlessCheckoutPaymentSplit[]>;
	/**
	 * Internal data dedicated to Purse usage.
	 * @internal
	 */
	__internal__: {
		session: PurseHeadlessCheckoutV1Params & {
			apiPaths: APIPaths | undefined;
		};
	};
	/**
	 * Cleans up resources and removes event listeners.
	 * @example
	 * ```ts
	 * headlessCheckout.teardown();
	 * ```
	 */
	teardown(): void;
	/**
	 * Sets the wallet session. The wallet session is used to retrieve and manage the user's stored card tokens.
	 * @param {OnePayWalletSession} walletSession
	 * @throws {PurseHeadlessCheckoutError} If setting the wallet session fails
	 * @example
	 * ```ts
	 * headlessCheckout.setWalletSession(walletSession);
	 * ```
	 */
	setWalletSession(walletSession: OnePayWalletSession): Promise<void>;
	/**
	 * Remove all tokens from the provided wallet session
	 * @throws {PurseHeadlessCheckoutWalletSessionMissingError} If the wallet session is missing
	 * @throws {PurseHeadlessCheckoutError} If deleting the tokens fails
	 * @example
	 * ```ts
	 * headlessCheckout.deleteAllTokens();
	 * ```
	 */
	deleteAllTokens(): Promise<void>;
	/**
	 * Clears the primary split from the amount share.
	 * Nothing happens if the primary split is already cleared.
	 * @example
	 * ```ts
	 * headlessCheckout.clearPrimarySplit();
	 * ```
	 */
	clearPrimarySplit(): void;
	/**
	 * Updates the session with the provided session data.
	 * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params['paymentSession']} widgetData - The session data. Can be either an encoded string (V2) or a payment session object (V1).
	 * @example
	 * ```ts
	 * headlessCheckout.setSession(paymentSession);
	 * ```
	 */
	setSession(widgetData: PurseHeadlessCheckoutV2Params): Promise<void>;
	setSession(widgetData: PurseHeadlessCheckoutV1Params["paymentSession"]): Promise<void>;
	setSession(widgetData: PurseHeadlessCheckoutV1Params["paymentSession"] | string): Promise<void>;
	/**
	 * Submits the current payment configuration for processing.
	 * This will validate and process all payment methods in the current split configuration.
	 *
	 * @throws {HeadlessCheckoutError} If:
	 *  - No payment methods are configured
	 *  - Payment validation fails
	 *  - Payment processing fails
	 *  - The total amount does not match the session amount
	 *
	 * @example
	 * ```typescript
	 * try {
	 *   // Configure payment methods and amounts
	 *   await primaryMethod.setAsPrimarySource();
	 *   await secondaryToken.take(50.00);
	 *
	 *   // Submit the payment
	 *   await checkout.submitPayment();
	 *   console.log('Payment successful!');
	 * } catch (error) {
	 *   console.error('Payment failed:', error);
	 * }
	 * ```
	 */
	submitPayment(): Promise<void>;
}
export interface PurseHeadlessCheckoutEventPayload {
	HEADLESS_CHECKOUT_CLEAR_PRIMARY_SPLIT: {
		partner: string;
		method: string;
	};
	HEADLESS_CHECKOUT_CLIENT_HOOK_ERROR: Record<never, never>;
	HEADLESS_CHECKOUT_CREATE: {
		sessionType: "v1" | "v2";
	};
	HEADLESS_CHECKOUT_DELETE_ALL_TOKENS: Record<never, never>;
	HEADLESS_CHECKOUT_EXPIRED_SESSION: {
		paymentSessionId: string;
	};
	HEADLESS_CHECKOUT_METHOD_GET_PAYMENT_ELEMENT: {
		partner: string;
		method: string;
		options?: string | Options;
	};
	HEADLESS_CHECKOUT_METHOD_GET_HOSTED_FIELDS: {
		partner: string;
		method: string;
		options?: string | Options;
	};
	HEADLESS_CHECKOUT_METHOD_GET_SECONDARY_TOKEN: Record<never, never>;
	HEADLESS_CHECKOUT_METHOD_LOAN_SIM: {
		partner: string;
		method: string;
	};
	HEADLESS_CHECKOUT_METHOD_REGISTER: {
		partner: string;
		method: string;
		saveToken: boolean;
	};
	HEADLESS_CHECKOUT_METHOD_SET_PRIMARY: {
		partner: string;
		method: string;
	};
	HEADLESS_CHECKOUT_OTHER_ERROR: Record<never, never>;
	HEADLESS_CHECKOUT_PAGE_UNLOAD: Record<never, never>;
	HEADLESS_CHECKOUT_PARTNER_UI_EVENT: {
		code: string;
		partner: string;
		method: string;
	} & Record<string, string | number | undefined>;
	HEADLESS_CHECKOUT_PAYMENT_ELEMENT_APPEND_TO: {
		partner: string;
		method: string;
	};
	HEADLESS_CHECKOUT_PAYMENT_ELEMENT_REMOVE: {
		partner: string;
		method: string;
		id?: string;
	};
	HEADLESS_CHECKOUT_PAYMENT_ELEMENT_SET_OPTIONS: {
		partner: string;
		method: string;
		options?: string | Options;
	};
	HEADLESS_CHECKOUT_PAYMENT_ELEMENT_VALIDATE_UI: {
		partner: string;
		method: string;
	};
	HEADLESS_CHECKOUT_PAYMENT_ELEMENT_LISTENER_ATTACHED: {
		partner: string;
		method: string;
		eventName?: string;
	};
	HEADLESS_CHECKOUT_VALIDATION_STARTED: Record<never, never>;
	HEADLESS_CHECKOUT_PRE_VALIDATION_FAILED: Record<never, never>;
	HEADLESS_CHECKOUT_VALIDATION_ENDED: Record<never, never>;
	HEADLESS_CHECKOUT_PAYMENT_ERROR: {
		message?: string;
		api_status?: string;
		stack?: string;
	};
	HEADLESS_CHECKOUT_PAYMENT_FULFILLED: {
		isFulfilled: boolean;
	};
	HEADLESS_CHECKOUT_PRIMARY_TOKEN_GET_PAYMENT_ELEMENT: {
		partner: string;
		method: string;
		id?: string;
	};
	HEADLESS_CHECKOUT_PRIMARY_TOKEN_SET_AS_PRIMARY: {
		partner: string;
		method: string;
	};
	HEADLESS_CHECKOUT_REACTIVE_VALUE_SUBSCRIBE: {
		variableName: string;
	};
	HEADLESS_CHECKOUT_READY: Record<never, never>;
	HEADLESS_CHECKOUT_SECONDARY_TOKEN_REGISTER: Record<never, never>;
	HEADLESS_CHECKOUT_SECONDARY_TOKEN_REMOVE_FROM_SPLIT: {
		partner: string;
		method: string;
		id?: string;
	};
	HEADLESS_CHECKOUT_SECONDARY_TOKEN_TAKE: {
		partner: string;
		method: string;
		amount?: number;
	};
	HEADLESS_CHECKOUT_SET_SESSION: {
		paymentSessionId: string;
		sessionType: "v1" | "v2" | "unknown";
		message?: string;
	};
	HEADLESS_CHECKOUT_SET_WALLET_SESSION: {
		walletSessionId: string;
	};
	HEADLESS_CHECKOUT_SET_WALLET_SESSION_FAILED: {
		message?: string;
		stack?: string;
	};
	HEADLESS_CHECKOUT_SUBMIT_PAYMENT: {
		splits: PaymentSplit[];
	};
	HEADLESS_CHECKOUT_TOKEN_DELETE: {
		partner: string;
		method: string;
		tokenId?: string;
	};
	HEADLESS_CHECKOUT_TOKEN_EDIT: {
		partner: string;
		method: string;
		tokenId?: string;
	};
	HEADLESS_CHECKOUT_UNCAUGHT_ERROR: Record<never, never>;
	HEADLESS_CHECKOUT_ON_BEFORE_VALIDATE_HOOK_FAILED: {
		message: string;
		error: {
			message: string;
			stack?: string;
		};
	};
}
export type PurseHeadlessCheckoutEventCode = keyof PurseHeadlessCheckoutEventPayload;
declare const EventScopes: {
	headlessCheckout: string[];
};
export interface PurseHeadlessCheckoutEventBusEvent<Code extends PurseHeadlessCheckoutEventCode = PurseHeadlessCheckoutEventCode> extends Event$1<PurseHeadlessCheckoutEventPayload[Code], Code> {
	code: Code;
	payload?: PurseHeadlessCheckoutEventPayload[Code];
}
declare class PurseHeadlessCheckoutEventBus extends EventBus<PurseHeadlessCheckoutEventBusEvent> {
	static readonly SCOPES: {
		headlessCheckout: string[];
	};
	static _instance?: PurseHeadlessCheckoutEventBus;
	private readonly _logQueue;
	private readonly _windowErrorWatcher;
	private constructor();
	post<T extends PurseHeadlessCheckoutEventCode>(event: PurseHeadlessCheckoutEventBusEvent<T>): void;
	unsubscribeAll(): void;
	subscribe(listener: EventListener$1<PurseHeadlessCheckoutEventBusEvent>, scopes?: Array<keyof typeof EventScopes | "*">): EventListenerTerminator;
	postFromCode<C extends PurseHeadlessCheckoutEventCode>(code: C, { type, payload, }?: {
		type?: keyof typeof EventType;
		payload?: PurseHeadlessCheckoutEventPayload[C];
	}): void;
	private beforeUnload;
	static getInstance(processLog?: (e: PurseHeadlessCheckoutEventBusEvent[]) => void): PurseHeadlessCheckoutEventBus;
}
declare class ApiLogger extends FetchMonitoringAPI<PurseHeadlessCheckoutEventBusEvent<any>> {
	constructor(env: EnvironmentTarget, apiKey: string, apiRoot?: string);
}
export interface PaymentSession {
	id: string;
	source: OrchestrationPaymentSession | LegacyPaymentSession;
	amount: number;
	amountCts: number;
	expirationDate: string;
	currency: string;
	vaultsConfiguration?: SessionVault["vendor_front_data"];
	meansOfPayment: PurseHeadlessCheckoutPaymentItem[];
}
export interface WalletSession {
	source: OnePayWalletSession$1;
	id: string;
	merchantID: string;
	expirationDate: string;
	ownerReference: string;
}
type OnePayWalletSession$1 = {
	expiration_date: string;
	session_id: string;
	owner_reference: string;
	merchant: string;
};
export interface Payment {
	api: PaymentAPI;
	walletAPI: WalletAPI;
	paymentSplitter: PaymentSplitter;
	factoriesStaticData: {
		manuallyTriggerHook: (hookName: keyof PurseHeadlessCheckoutHooks) => Promise<void>;
		submitPayment: (skipOnBeforeValidateHook?: boolean) => Promise<void>;
	};
	mops: Readable<PurseHeadlessCheckoutPaymentItem[]>;
	methods: Readable<PurseHeadlessCheckoutPaymentMethod[]>;
	tokens: Readable<PurseHeadlessCheckoutPaymentToken[]>;
	walletTokens: Readable<WalletItem[]>;
	session: PaymentSession;
	walletSession: WalletSession | null;
	setSession(session: OrchestrationPaymentSession | LegacyPaymentSession): Promise<void>;
	onExpires(callback: () => void): () => void;
	getMop(mop: Partial<PurseHeadlessCheckoutPaymentItemBase>): PurseHeadlessCheckoutPaymentItem | null;
	deleteAllTokens(): Promise<void>;
	deactivateMop(mop: PurseHeadlessCheckoutPaymentItemBase, reason: DisabledState): Promise<void>;
	isSessionExpired(): boolean;
}
declare class PursePayment implements Payment {
	readonly factoriesStaticData: {
		manuallyTriggerHook: (hookName: keyof PurseHeadlessCheckoutHooks) => Promise<void>;
		submitPayment: (skipOnBeforeValidateHook?: boolean) => Promise<void>;
	};
	private _paymentSession;
	private _walletSession;
	private readonly _serverDateChecker;
	api: PaymentAPI;
	walletAPI: WalletAPI;
	paymentSplitter: PaymentSplitter;
	mops: Writable<PurseHeadlessCheckoutPaymentItem[]>;
	methods: Readable<PurseHeadlessCheckoutPaymentMethod[]>;
	tokens: Readable<PurseHeadlessCheckoutPaymentToken[]>;
	walletTokens: Readable<WalletItem[]>;
	constructor(env: APIEnv, factoriesStaticData: {
		manuallyTriggerHook: (hookName: keyof PurseHeadlessCheckoutHooks) => Promise<void>;
		submitPayment: (skipOnBeforeValidateHook?: boolean) => Promise<void>;
	});
	get session(): PaymentSession;
	get walletSession(): WalletSession | null;
	setSession(session: OrchestrationPaymentSession | LegacyPaymentSession): Promise<void>;
	setWalletSession(session: OnePayWalletSession): Promise<void>;
	onExpires(callback: () => void): () => void;
	getMop(mop: Partial<PurseHeadlessCheckoutPaymentItem>): PurseHeadlessCheckoutPaymentItem | null;
	deleteAllTokens(): Promise<void>;
	deactivateMop(mop: PurseHeadlessCheckoutPaymentItem, reason: DisabledState): Promise<void>;
	isSessionExpired(): boolean;
	private updateMopDisabledState;
}
export declare class PurseHeadlessCheckout implements HeadlessCheckout {
	#private;
	protected _env: APIEnv;
	protected _payment: PursePayment;
	protected _eventBus: PurseHeadlessCheckoutEventBus;
	protected _apiLogger: ApiLogger;
	private readonly _hooks?;
	/**
	 * Current paymentSessionID readable value;
	 */
	readonly currentSessionID: Readable<string | null>;
	/**
	 * List of available payment methods for the checkout.
	 * This property is a Writable object containing an array of PurseCheckoutPaymentMethod.
	 * Each payment-element in the array represents a payment method with its associated properties.
	 * @type {Readable<Array<PurseHeadlessCheckoutPaymentMethod>>}
	 * @example
	 * ```ts
	 * headlessCheckout.paymentMethods.subscribe((methods: PurseCheckoutPaymentMethod[]) => {
	 *    console.log('The payment methods changed', methods);
	 *    // Perhaps update the UI with the new methods
	 * });
	 * ```
	 */
	readonly paymentMethods: Writable<PurseHeadlessCheckoutPaymentMethod[]>;
	/**
	 * List of available payment tokens for the checkout.
	 * This property is a Writable object containing an array of PurseCheckoutPaymentToken.
	 * Each payment-element in the array represents a payment token with its associated properties.
	 * @type {Readable<Array<PurseHeadlessCheckoutPaymentToken>>}
	 * @example
	 * ```ts
	 * headlessCheckout.paymentTokens.subscribe((tokens: PurseCheckoutPaymentToken[]) => {
	 *   console.log('The payment tokens changed', tokens);
	 *   // Perhaps update the UI with the new tokens
	 * });
	 * ```
	 */
	readonly paymentTokens: Writable<PurseHeadlessCheckoutPaymentToken[]>;
	/**
	 * This property indicates if the payment can be submitted.
	 * @example
	 * ```ts
	 * headlessCheckout.isPaymentFulfilled.subscribe((isFulfilled: boolean) => {
	 *    if(isFulfilled) {
	 *      enablePayButton();
	 *    }else{
	 *      disablePayButton();
	 *    }
	 * });
	 * ```
	 */
	readonly isPaymentFulfilled: Readable<boolean>;
	/**
	 * The remaining amount to pay represents the amount that is left to pay after the secondary payment method(s) has been used.
	 * @example
	 * ```ts
	 * headlessCheckout.remainingAmountToPay.subscribe((amount: number) => {
	 *    console.log('Perhaps update the text in your pay button', amount);
	 * });
	 * ```
	 * */
	remainingAmountToPay: Readable<number>;
	/**
	 * Splits represent the repartition between the primary payment method and the secondary payment methods.
	 * @link PurseHeadlessCheckoutPaymentSplit
	 * @example
	 * ```ts
	 * headlessCheckout.amountSplit.subscribe((splits: PurseHeadlessCheckoutPaymentSplit[]) => {
	 *    console.log('The payment composition changed', splits);
	 * });
	 * ```
	 * */
	amountSplit: Readable<PaymentSplit[]>;
	/**
	 * The current state of the checkout session.
	 * It can be one of the following values:
	 * - 'idle': The session is idle and not yet initialized.
	 * - 'ready': The session is initialized and ready for payment method selection.
	 * - 'submitting': The payment is being submitted.
	 * - 'submitted': The payment has been successfully submitted.
	 * - 'expired': The session has expired.
	 * - 'error': An error occurred with the session.
	 * @example
	 * ```ts
	 * headlessCheckout.sessionState.subscribe((state: PurseHeadlessCheckoutSessionState) => {
	 *    console.log('The session state changed', state);
	 *    if(state === 'expired') {
	 *      alertUserSessionExpired();
	 *    }
	 * });
	 * ```
	 */
	sessionState: Derived<PurseHeadlessCheckoutSessionState, [
		Writable<PurseHeadlessCheckoutSessionState>
	]>;
	/**
	 * Internal data dedicated to Purse usage.
	 */
	readonly __internal__: {
		session: PurseHeadlessCheckoutV1Params & {
			apiPaths: APIPaths | undefined;
		};
	};
	private constructor();
	/**
	 * @internal
	 * Creates an instance of HeadlessCheckout.
	 * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params} checkoutParams - The checkoutParams data for initializing the checkout.
	 * @param {PurseHeadlessCheckoutHooks} hooks - Optional hooks into checkout lifecycle
	 * @param {APIPaths} apiPaths @internal - dev purposes to override the APi URL's
	 * @param product @internal - dev purposes to override the product name
	 */
	static init(checkoutParams: PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params, hooks?: PurseHeadlessCheckoutHooks, apiPaths?: APIPaths): Promise<PurseHeadlessCheckout>;
	/**
	 * Get the config from params
	 * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params} checkoutParams - The checkoutParams data for initializing the checkout.
	 * @param {APIPaths} apiPaths - dev purposes only to override the APi URL's
	 */
	static getConfigFromParams(checkoutParams: PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params, apiPaths?: APIPaths): PurseHeadlessCheckoutV1Params & {
		apiPaths: APIPaths | undefined;
	};
	/**
	 * Cleans up resources and removes event listeners.
	 * @example
	 * ```ts
	 * headlessCheckout.teardown();
	 * ```
	 */
	teardown(): void;
	/**
	 * Sets the wallet session. The wallet session is used to retrieve and manage the user's stored card tokens.
	 *
	 * @param {WalletSessionModel} walletSession
	 *
	 * @throws {@link PurseHeadlessCheckoutError} `SET_WALLET_SESSION_FAILED` \
	 * If setting the wallet session fails
	 *
	 * @example
	 * ```ts
	 * headlessCheckout.setWalletSession(walletSession);
	 * ```
	 */
	setWalletSession(walletSession: OnePayWalletSession): Promise<void>;
	/**
	 * Remove all tokens from the provided wallet session
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `MISSING_WALLET_SESSION` \
	 * If the wallet session is missing
	 * - {@link PurseHeadlessCheckoutError} `FAILED_TO_DELETE_ALL_TOKENS` \
	 * If deleting the tokens fails
	 *
	 * @example
	 * ```ts
	 * headlessCheckout.deleteAllTokens();
	 * ```
	 */
	deleteAllTokens(): Promise<void>;
	/**
	 * Clears the primary split from the amount share.
	 * Nothing happens if the primary split is already cleared.
	 * @example
	 * ```ts
	 * headlessCheckout.clearPrimarySplit();
	 * ```
	 */
	clearPrimarySplit(): void;
	protected _setSession(session: PurseHeadlessCheckoutV1Params["paymentSession"]): Promise<void>;
	/**
	 * @internal
	 * Manually trigger a hook out of the standard process
	 * @param hookName
	 * @private
	 */
	private manuallyTriggerHook;
	/**
	 * Updates the session with the provided session data.
	 * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params['paymentSession']} widgetData - The session data. Can be either an encoded string (V2) or a payment session object (V1).
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `MISSING_SESSION` \
	 * If setting the session fails
	 * - {@link PurseHeadlessCheckoutError} `UNKNOWN_ERROR` \
	 * If an unknown error is caught during the session update
	 *
	 * @example
	 * ```ts
	 * headlessCheckout.setSession(paymentSession);
	 * ```
	 */
	setSession(widgetData: PurseHeadlessCheckoutV2Params): Promise<void>;
	setSession(widgetData: PurseHeadlessCheckoutV1Params["paymentSession"]): Promise<void>;
	private _submitPayment;
	/**
	 * Submits the current payment configuration for processing.
	 * This will validate and process all payment methods in the current split configuration.
	 *
	 * @throws
	 * - {@link PurseHeadlessCheckoutError} `MISSING_SESSION` \
	 * If the session is missing
	 * - {@link PurseHeadlessCheckoutError} `PAYMENT_NOT_FULFILLED_ON_SUBMIT` \
	 * If submitting a payment not available for submission
	 * - {@link PurseHeadlessCheckoutError} `POST_VALIDATE_FAILED` \
	 * If the post-validation step of the payment process fails
	 * - {@link PurseHeadlessCheckoutError} `UI_VALIDATION_FAILED_ERROR` \
	 * If the pre-validation step of the payment process fails
	 * - {@link PurseHeadlessCheckoutError} `VALIDATE_FAILED` \
	 * If the validate step of the payment process fails
	 *
	 * @example
	 * ```typescript
	 * try {
	 *   // Configure payment methods and amounts
	 *   await primaryMethod.setAsPrimarySource();
	 *   await secondaryToken.take(50.00);
	 *
	 *   // Submit the payment
	 *   await checkout.submitPayment();
	 *   console.log('Payment successful!');
	 * } catch (error) {
	 *   console.error('Payment failed:', error);
	 * }
	 * ```
	 */
	submitPayment(skipOnBeforeValidateHook?: boolean): Promise<void>;
}
/**
 * Creates and initializes a new headless checkout instance.
 * Use this function to start a new payment session with the Purse checkout system.
 * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params} sessionParams - The checkout session configuration.
 * @param hooks - Optional lifecycle hooks to customize checkout behavior
 *               See {@link PurseHeadlessCheckoutHooks} for available hooks
 *
 * @param apiPaths - dev purposes only to override the APi URL's'
 * @throws
 * - {@link PurseHeadlessCheckoutError} `EXPIRED_SESSION` \
 * If the session used to create the headless checkout instance is expired.
 * - {@link PurseHeadlessCheckoutError} `INVALID_INIT_PARAMS` \
 * If the parameters used to init the headless checkout are invalid.
 * - {@link PurseHeadlessCheckoutError} `UNKNOWN_ERROR` \
 * If tan unknown error is caught during the creation of the headless checkout instance.
 *
 * @returns A promise that resolves to a configured checkout instance
 */
export declare const createHeadlessCheckout: <T extends PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params, H extends PurseHeadlessCheckoutHooks>(sessionParams: T, hooks?: H, apiPaths?: APIPaths) => Promise<PurseHeadlessCheckout>;
declare const PurseHeadlessCheckoutErrors: {
	readonly ELEMENT_NOT_FULFILLED: {
		readonly code: "ELEMENT_NOT_FULFILLED";
		readonly message: "Payment element must be fulfilled for this action.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#element_not_fulfilled";
	};
	readonly ELEMENT_RENDER_FAILED: {
		readonly code: "ELEMENT_RENDER_FAILED";
		readonly message: "An error occurred while rendering the payment element";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#element_render_failed";
	};
	readonly INVALID_LOAN_SIMULATION: {
		readonly code: "INVALID_LOAN_SIMULATION";
		readonly message: "The Load Simulation API response does not contain valid simulation data.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#invalid_loan_simulation";
	};
	readonly UI_VALIDATION_FAILED_ERROR: {
		readonly code: "UI_VALIDATION_FAILED_ERROR";
		readonly message: "Partner's form is not complete, sometimes the form internal state cannot be accessed and fulfilled is sent right on creation. Visual queues are displayed for the user.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#ui_validation_failed_error";
	};
	readonly USAGE_LIMIT_ERROR: {
		readonly code: "USAGE_LIMIT_ERROR";
		readonly message: "Usage limit reached for partner and method.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#usage_limit_error";
	};
	readonly SECONDARY_METHOD_REQUIRED_CVV: {
		readonly code: "SECONDARY_METHOD_REQUIRED_CVV";
		readonly message: "This method and pan combination requires a CVV.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#secondary_method_required_cvv";
	};
	readonly SECONDARY_METHOD_WRONG_PAN_FORMAT: {
		readonly code: "SECONDARY_METHOD_WRONG_PAN_FORMAT";
		readonly message: "The provided pan does not respect the expected format.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#secondary_method_wrong_pan_format";
	};
	readonly SECONDARY_METHOD_WRONG_CVV_FORMAT: {
		readonly code: "SECONDARY_METHOD_WRONG_CVV_FORMAT";
		readonly message: "The provided cvv does not respect the expected format.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#secondary_method_wrong_cvv_format";
	};
	readonly SECONDARY_METHOD_TAKE_POLICY_VIOLATED: {
		readonly code: "SECONDARY_METHOD_TAKE_POLICY_VIOLATED";
		readonly message: "This method has a strict take policy and cannot be used with any amount.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#secondary_method_take_policy_violated";
	};
	readonly METHOD_NOT_IMPLEMENTED: {
		readonly code: "METHOD_NOT_IMPLEMENTED";
		readonly message: "The invoked method is not implemented.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#method_not_implemented";
	};
	readonly INVALID_TAKE_AMOUNT: {
		readonly code: "INVALID_TAKE_AMOUNT";
		readonly message: "Cannot perform \"take\" with an invalid amount.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#invalid_take_amount";
	};
	readonly PAYMENT_NOT_FULFILLED_ON_SUBMIT: {
		readonly code: "PAYMENT_NOT_FULFILLED_ON_SUBMIT";
		readonly message: "Payment not fulfilled while submitting payment.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#payment_not_fulfilled_on_submit";
	};
	readonly PAYMENT_METHOD_NOT_FOUND: {
		readonly code: "PAYMENT_METHOD_NOT_FOUND";
		readonly message: "Method not found.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#payment_method_not_found";
	};
	readonly UNKNOWN_ERROR: {
		readonly code: "UNKNOWN_ERROR";
		readonly message: "An error occurred.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#unknown_error";
	};
	readonly ON_BEFORE_VALIDATE_HOOK_FAILED: {
		readonly code: "ON_BEFORE_VALIDATE_HOOK_FAILED";
		readonly message: "The hook onBeforeValidate failed.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#on_before_validate_hook_failed";
	};
	readonly NOT_SUPPORTED_BRAND: {
		readonly code: "NOT_SUPPORTED_BRAND";
		readonly message: "The brand is not supported.";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#not_supported_brand";
	};
	readonly BRAND_NOT_BELONGS_TO_DETECTED: {
		readonly code: "BRAND_NOT_BELONGS_TO_DETECTED";
		readonly message: "The brand is not one of the detected ones";
		readonly documentationLink: "https://docs.purse.tech/docs/integrate/purse-checkout/headless-checkout/error-handling/error-codes#brand_not_belongs_to_detected";
	};
	readonly METHOD_NOT_REGISTERABLE: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly METHOD_DISABLED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly METHOD_IS_NOT_SIMULABLE: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly VALIDATE_FAILED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly POST_VALIDATE_FAILED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly INVALID_INIT_PARAMS: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly FAILED_TO_INIT_SECONDARY_TOKEN: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_NOT_REGISTERABLE: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_NOT_REGISTERED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_NAME_EXISTS: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MISSING_TOKEN: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly INVALID_TOKEN_NAME: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly FAILED_TO_DELETE_ALL_TOKENS: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly FAILED_TO_ADD_TOKEN: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly TOKEN_ALREADY_EXISTS: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly PAYMENT_TOKEN_NOT_FOUND_IN_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly EXPIRED_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SESSION_ALREADY_SET: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MISSING_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly MISSING_WALLET_SESSION: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SET_WALLET_SESSION_FAILED: {
		code: string;
		message: string;
		documentationLink: string;
	};
	readonly SESSION_MALFORMED: {
		code: string;
		message: string;
		documentationLink: string;
	};
};
export type PurseHeadlessCheckoutErrorCodes = keyof typeof PurseHeadlessCheckoutErrors;
type JsonSerializable$1 = string | number | boolean | null | {
	[key: string]: JsonSerializable$1 | undefined;
} | JsonSerializable$1[];
/**
 * @description
 * Custom error class for handling errors specific to the Purse Headless Checkout SDK.
 *
 * @example
 * ```ts
 * let checkout: PurseHeadlessCheckout;
 *
 * try {
 *   checkout = await Purse.createHeadlessCheckout({
 *     ...
 *   });
 * } catch(e) {
 *   if (e instanceof PurseHeadlessCheckoutError) {
 *     switch(e.code) {
 *       case 'INVALID_INIT_PARAMS':
 *         // Handle expired session
 *         break;
 *       // Handle other error codes as needed
 *       default:
 *         console.error('An unexpected error occurred:', e);
 *     }
 *   } else {
 *     console.error('A non-headless checkout error occurred:', e);
 *   }
 * }
 * ```
 */
export declare class PurseHeadlessCheckoutError extends Error {
	readonly code: PurseHeadlessCheckoutErrorCodes;
	readonly documentationLink: string;
	readonly additionalPayload?: JsonSerializable$1 | Error;
	constructor(error: (typeof PurseHeadlessCheckoutErrors)[PurseHeadlessCheckoutErrorCodes], additionalPayload?: JsonSerializable$1 | Error);
}

export {
	HostedFormUIOptions as PurseHeadlessCheckoutHostedFormUIOptions,
	Options as PurseHeadlessCheckoutUIOptions,
	PartnerUIOptionsTheme as PurseHeadlessCheckoutPartnerUIOptionsTheme,
	PartnerUITheme as PurseHeadlessCheckoutPartnerUITheme,
	XPayButtonUIOptions as PurseHeadlessCheckoutXPayButtonUIOptions,
};

export {};
