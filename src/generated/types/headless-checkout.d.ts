// Generated by dts-bundle-generator v9.5.1

/// <reference types="googlepay" />

declare abstract class API {
    root: string;
    env: APIEnvironment;
    apiKey: string;
    entityId: string;
    private _fetcher;
    private readonly _beacon?;
    constructor({ environment, apiKey, entityId, root, beacon }: APIConstructor);
    fetchJSON<T>(path: string, config?: any, parser?: (any: any) => T): Promise<APIResponse<T>>;
    private buildUrl;
    sendBeacon<T>(path: string, data: T): void;
    fetch(path: string, config?: any): Promise<any>;
    private _addHeaders;
    _buildHeader(): Promise<APIHeader>;
    private _withBeaconQueryParams;
    toJSON(): {
        root: string;
        entityId: string;
        env: APIEnvironment;
    };
    private _getFetcher;
}
declare abstract class PaymentItem$1<SourceType, Actions extends ItemActions = typeof NoopActions> implements PaymentItemInterface<Actions> {
    partner: string;
    source: SourceType;
    paymentData: Writable<any>;
    partnerData: Writable<any>;
    orderData: Writable<any>;
    paymentPreferences: Writable<any>;
    deactivated: Writable<boolean>;
    _actionsBuilder?: PaymentItemActionsBuilder<Actions>;
    _actions?: Actions;
    /**
     * in some cases, methods are merged under a constructed and must be able to override the method name at validate.
     */
    private _reWiredMethodName;
    private _method;
    constructor({ partner, method, source, actions, }: {
        partner: string;
        method: string;
        source: SourceType;
        actions?: PaymentItemActionsBuilder<Actions>;
    });
    get method(): string;
    get actions(): Actions | undefined;
    buildData(): PaymentItemData;
    setSource(source: SourceType): void;
    abstract get id(): string;
    abstract get isSecondary(): boolean;
    static getId(partner: string, method: string): string;
    deactivate(): void;
    activate(): void;
    toJSON(): {
        id: string;
        secondary: boolean;
        partner: string;
        method: string;
    };
    isEqual(item: PaymentItemInterface<Actions>): boolean;
    rewireMethodName(method: string | null): void;
}
declare abstract class Session<Type extends AbstractSessionModel> {
    source: Type;
    private _expired;
    expiration: Readable<boolean>;
    private serverOffset;
    constructor(source: Type, serverOffset?: number | null);
    abstract get id(): any;
    verifyExpiration(): void;
    subscribeToExpiration(listener: StoreSubscriber<boolean>): StoreUnsubscriber;
    isExpired(): boolean;
}
declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
    readonly _type: Output;
    readonly _output: Output;
    readonly _input: Input;
    readonly _def: Def;
    get description(): string | undefined;
    "~standard": StandardSchemaV1.Props<Input, Output>;
    abstract _parse(input: ParseInput): ParseReturnType<Output>;
    _getType(input: ParseInput): string;
    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;
    _processInputParams(input: ParseInput): {
        status: ParseStatus;
        ctx: ParseContext;
    };
    _parseSync(input: ParseInput): SyncParseReturnType<Output>;
    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;
    parse(data: unknown, params?: util.InexactPartial<ParseParams>): Output;
    safeParse(data: unknown, params?: util.InexactPartial<ParseParams>): SafeParseReturnType<Input, Output>;
    "~validate"(data: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>>;
    parseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<Output>;
    safeParseAsync(data: unknown, params?: util.InexactPartial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;
    /** Alias of safeParseAsync */
    spa: (data: unknown, params?: util.InexactPartial<ParseParams>) => Promise<SafeParseReturnType<Input, Output>>;
    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;
    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;
    _refinement(refinement: RefinementEffect<Output>["refinement"]): ZodEffects<this, Output, Input>;
    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;
    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;
    constructor(def: Def);
    optional(): ZodOptional<this>;
    nullable(): ZodNullable<this>;
    nullish(): ZodOptional<ZodNullable<this>>;
    array(): ZodArray<this>;
    promise(): ZodPromise<this>;
    or<T extends ZodTypeAny>(option: T): ZodUnion<[
        this,
        T
    ]>;
    and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;
    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;
    default(def: util.noUndefined<Input>): ZodDefault<this>;
    default(def: () => util.noUndefined<Input>): ZodDefault<this>;
    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;
    catch(def: Output): ZodCatch<this>;
    catch(def: (ctx: {
        error: ZodError;
        input: Input;
    }) => Output): ZodCatch<this>;
    describe(description: string): this;
    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;
    readonly(): ZodReadonly<this>;
    isOptional(): boolean;
    isNullable(): boolean;
}
declare class Amount {
    total: Currency;
    currencyCode: string;
    primary: Writable<PaymentItemInterface<CheckoutActions> | null>;
    fulfilled: Readable<boolean>;
    private splits;
    private _unsubscribeFromPrimarySuspension?;
    constructor(amount?: number, currencyCode?: string);
    get isMultiPartner(): Derived<boolean, [
        Writable<PaymentSplit[]>,
        Writable<PaymentItemInterface<CheckoutActions> | null>
    ]>;
    reset(amount: number | undefined, currencyCode: string): Amount;
    setPrimarySource(source: PaymentItemInterface<any> | null): PaymentSplit | null;
    takeSplit({ token, amount: srcAmount, minIncrement, }: {
        token: PaymentItemInterface;
        amount: number;
        minIncrement?: number;
    }): PaymentSplit | null;
    getItemSplit({ paymentItem, splits, }: {
        paymentItem: PaymentItemInterface;
        splits?: PaymentSplit[];
    }): PaymentSplit | null;
    getItemReach({ paymentItem }: {
        paymentItem: PaymentItemInterface;
    }): number;
    clearSplit(source: PaymentItemInterface): PaymentSplit | null;
    clearAllSplits(): PaymentSplit[];
    getRestToPay(): number;
    getPrimaryReach: () => number;
    getPrimaryReachDerived(): Derived<number, [
        Writable<PaymentSplit[]>
    ]>;
    getSecondariesAmount(): number;
    getSplits(): PaymentSplit[];
    getSplitsDataWithAmount<Actions extends ItemActions = typeof NoopActions>(): {
        data: {
            amount: number;
        } & PaymentItemData;
        item: PaymentItemInterface<Actions>;
    }[];
    getSplitsTotal(): number;
    getPrimarySplit(): PaymentSplit | null;
    getItemReachDerived(paymentItem: PaymentItemInterface): Readable<number>;
    getSplitDerived(): Readable<[
        PaymentSplit[],
        PaymentItem$1<CheckoutActions>
    ]>;
    getItemSplitDerived(paymentItem: PaymentItemInterface): Readable<PaymentSplit | null>;
    getMainItemDerived(): Readable<PaymentItemInterface | null>;
    deriveFromSplits<T>(updater: (values: any, set?: any) => any): Readable<T>;
    getSecondariesSplits(): PaymentSplit[];
    isMethodLimitReachedDerived(paymentItem: PaymentMethod | PaymentToken): Readable<boolean>;
    getMethodAmountSuspensionDerived(paymentMethod: PaymentMethod<any>): Readable<number | undefined>;
    private _createUpdateSplit;
    private _deleteSplit;
    private _resetSplits;
    private _handleSplitsUpdate;
    private _getAmountForIncrement;
}
declare class Checkout<Actions extends ItemActions = CheckoutActions> {
    #private;
    session?: PaymentSession<Actions>;
    payment: Amount;
    api: FetchGatewayAPI;
    env: Environment;
    validationIsRolling: Writable<boolean>;
    private _validated;
    private _sessionExpiredUnsub?;
    private _paymentFulfiledUnsub?;
    private _currentActionBuilder?;
    eventBus: CheckoutEventBus;
    constructor({ apiKey, entityId, environment, paymentItemActionsBuilder, rootOverrides, }: {
        apiKey: string;
        entityId: string;
        environment: EnvironmentTarget;
        paymentItemActionsBuilder?: PaymentItemActionsBuilder<Actions>;
        rootOverrides?: APIPaths;
    });
    get validated(): boolean;
    get validationResult(): ValidationData | null;
    get _actionBuilder(): PaymentItemActionsBuilder<Actions> | undefined;
    set _actionBuilder(builder: PaymentItemActionsBuilder<Actions> | undefined);
    setSession({ session, actionBuilder, onExpires, }: {
        session: PaymentSessionModel;
        actionBuilder?: PaymentItemActionsBuilder<Actions>;
        onExpires?: () => void;
    }): Promise<Checkout<Actions>>;
    validatePayment(redirection?: RedirectionHandler, hooks?: {
        preValidate?: (d: {
            participants: {
                partner: string;
                method: string;
                amount: number;
            }[];
        }) => Promise<void> | void;
        postValidate?: () => Promise<void> | void;
    }): Promise<ValidationData | null>;
    getSimulationCandidates(product: SimulationCandidatePayload): Promise<APIResponse<SimulationCandidate[]>>;
    getSimulation(partner: string, method: string, product: SimulationCandidatePayload): Promise<APIResponse<SimulationCandidate>>;
    private setServerTimeOffset;
    private _onSessionValidityChanges;
    private _onPaymentFulfillChanges;
    private _validationHandle;
}
declare class CheckoutActions implements ItemActions {
    method: PaymentMethod<any>;
    token?: PaymentToken<any>;
    checkout: Checkout<any>;
    suspension: Readable<PaymentMethodSuspensions>;
    amountSuspension: Readable<number | undefined>;
    externalSuspension: Writable<boolean>;
    balance?: Writable<number>;
    stepId: number | null;
    constructor({ method, token, checkout, }: {
        method: PaymentMethod<ItemActions>;
        token?: PaymentToken<ItemActions>;
        checkout: Checkout<ItemActions>;
    });
    buildData(): {
        step_id: number | null;
    };
    init<T = void>(payloadOverride?: {
        [key: string]: any;
    }): Promise<APIResponse<InitData<T>>>;
    getInitPayload(payloadOverride?: {
        [p: string]: any;
    }): {
        method: string;
        partner: string;
        amount: number;
        paymentData?: any;
        partnerData?: any;
        order?: any;
        paymentPreferences?: any;
        step_id?: number | undefined;
    };
    askForValidation(): Promise<boolean>;
    preValidate(payload: {
        amount: number;
    } & PaymentItemData): Promise<void>;
    postValidate(_: {
        validation: ValidationData;
        result: ItemValidationData;
        redirection: RedirectionHandler;
    }): Promise<boolean>;
    setAsPrimarySource(): Promise<void>;
    clearPartFromPayment(): Promise<void>;
    getSimulation(product: any): Promise<APIResponse<{
        plugin_result?: {
            final_instalment_amount: number;
            initial_instalment_amount: number;
            instalment_amount: number;
            instalment_number: number;
            preferred: boolean;
            total_cost: number;
            effective_annual_percentage_rate?: number | undefined;
            legal_text?: string | undefined;
        } | null | undefined;
    }>>;
    takeSplitInAmount(amount: number, minIncrement?: number): PaymentSplit | null;
    getDerivedSplitFromAmount(): Readable<PaymentSplit | null>;
    getIsLimitedFromAmount(): Readable<boolean>;
    setBalance(value: number): Promise<void>;
}
declare class CheckoutEvent<Payload = any> implements Event$1<Payload> {
    code: string;
    dateString: string;
    type: EventType;
    payload?: Payload;
    constructor({ code, payload, type }: {
        code: string;
        type?: EventType;
        payload?: Payload;
    });
}
declare class CheckoutEventBus extends EventBus<CheckoutEvent> {
    static CODES: {
        readonly CHECKOUT_SESSION_SET: "CHECKOUT_SESSION_SET";
        readonly CHECKOUT_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME: "CHECKOUT_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME";
        readonly CHECKOUT_SESSION_EXPIRED: "CHECKOUT_SESSION_EXPIRED";
        readonly CHECKOUT_VALIDATION_START: "CHECKOUT_VALIDATION_START";
        readonly CHECKOUT_API_START: "CHECKOUT_API_START";
        readonly CHECKOUT_API_END: "CHECKOUT_API_END";
        readonly CHECKOUT_API_INIT_SUCCEEDED: "CHECKOUT_API_INIT_SUCCEEDED";
        readonly CHECKOUT_API_INIT_FAILED: "CHECKOUT_API_INIT_FAILED";
        readonly CHECKOUT_API_VALIDATION_SUCCEEDED: "CHECKOUT_API_VALIDATION_SUCCEEDED";
        readonly CHECKOUT_POST_VALIDATION_SUCCEEDED: "CHECKOUT_POST_VALIDATION_SUCCEEDED";
        readonly CHECKOUT_POST_VALIDATION_FAILED: "CHECKOUT_POST_VALIDATION_FAILED";
        readonly CHECKOUT_VALIDATION_SUCCEEDED: "CHECKOUT_VALIDATION_SUCCEEDED";
        readonly CHECKOUT_VALIDATION_FAILED: "CHECKOUT_VALIDATION_FAILED";
        readonly CHECKOUT_INTERNAL_3DS_STEP: "CHECKOUT_INTERNAL_3DS_STEP";
        readonly CHECKOUT_PRE_VALIDATION_FAILED: "CHECKOUT_PRE_VALIDATION_FAILED";
        readonly CHECKOUT_PRE_VALIDATION_ALREADY_ROLLING: "CHECKOUT_PRE_VALIDATION_ALREADY_ROLLING";
        readonly CHECKOUT_PRE_VALIDATION_STARTING: "CHECKOUT_PRE_VALIDATION_STARTING";
        readonly CHECKOUT_PAYMENT_FULFILLED_CHANGES: "CHECKOUT_PAYMENT_FULFILLED_CHANGES";
        readonly CHECKOUT_PAYMENT_FULLFILLED_ERROR: "CHECKOUT_PAYMENT_FULLFILLED_ERROR";
        readonly WALLET_SESSION_SET: "WALLET_SESSION_SET";
        readonly WALLET_SESSION_EXPIRED: "WALLET_SESSION_EXPIRED";
        readonly WALLET_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME: "WALLET_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME";
        readonly WALLET_TOKEN_DELETION_COMPLETE: "WALLET_TOKEN_DELETION_COMPLETE";
        readonly WALLET_TOKEN_EDITION_COMPLETE: "WALLET_TOKEN_EDITION_COMPLETE";
        readonly WALLET_ALL_TOKENS_DELETION_COMPLETE: "WALLET_ALL_TOKENS_DELETION_COMPLETE";
        readonly WALLET_TOKEN_SET_AS_FAVORITE: "WALLET_TOKEN_SET_AS_FAVORITE";
        readonly WIDGET_MANAGER_CREATE: "WIDGET_MANAGER_CREATE";
        readonly WIDGET_MANAGER_ANALYTICS: "WIDGET_MANAGER_ANALYTICS";
        readonly WIDGET_MANAGER_SUBMIT_PAYMENT: "WIDGET_MANAGER_SUBMIT_PAYMENT";
        readonly WIDGET_SUBMIT_PAYMENT: "WIDGET_SUBMIT_PAYMENT";
        readonly WIDGET_GET_PLUGIN_FAILED: "WIDGET_GET_PLUGIN_FAILED";
        readonly WIDGET_PROTOCOL_UNSTABLE_FILTER: "WIDGET_PROTOCOL_UNSTABLE_FILTER";
        readonly WIDGET_PROTOCOL_PLUGIN_NOT_IMPLEMENTED: "WIDGET_PROTOCOL_PLUGIN_NOT_IMPLEMENTED";
        readonly WIDGET_CREATE: "WIDGET_CREATE";
        readonly WIDGET_MOUNTED: "WIDGET_MOUNTED";
        readonly WIDGET_UNMOUNTED: "WIDGET_UNMOUNTED";
        readonly WIDGET_FETCH_CONFIG_FAILED_SOFTLY: "WIDGET_FETCH_CONFIG_FAILED_SOFTLY";
        readonly WIDGET_CONFIG_NAME_IS_MANDATORY_SHOULD_BE_UNIQUE: "WIDGET_CONFIG_NAME_IS_MANDATORY_SHOULD_BE_UNIQUE";
        readonly WIDGET_CONFIG_SET: "WIDGET_CONFIG_SET";
        readonly WIDGET_MERGE_NAVIGATION_SELECTION_UPDATE: "WIDGET_MERGE_NAVIGATION_SELECTION_UPDATE";
        readonly WIDGET_MERGE_NAVIGATION_SELECTION_SKIPPED: "WIDGET_MERGE_NAVIGATION_SELECTION_SKIPPED";
        readonly WIDGET_MERGE_NAVIGATION_FOCUS_UPDATE: "WIDGET_MERGE_NAVIGATION_FOCUS_UPDATE";
        readonly WIDGET_MERGE_NAVIGATION_TRY_TO_SELECT_SUSPENDED_ITEM: "WIDGET_MERGE_NAVIGATION_TRY_TO_SELECT_SUSPENDED_ITEM";
        readonly WIDGET_MERGE_NAVIGATION_SELECTED_ITEM_IS_NOW_SUSPENDED: "WIDGET_MERGE_NAVIGATION_SELECTED_ITEM_IS_NOW_SUSPENDED";
        readonly WIDGET_MERGE_NAVIGATION_OPEN_UPDATE: "WIDGET_MERGE_NAVIGATION_OPEN_UPDATE";
        readonly WIDGET_NAVIGATION_PRIMARY_UPDATE: "WIDGET_NAVIGATION_PRIMARY_UPDATE";
        readonly WIDGET_NAVIGATION_SECONDARY_UPDATE: "WIDGET_NAVIGATION_SECONDARY_UPDATE";
        readonly WIDGET_SUBMISSION_AFTER_PARTNER_SDK_REJECTION: "WIDGET_SUBMISSION_AFTER_PARTNER_SDK_REJECTION";
        readonly WIDGET_UI_SAVE_TOKEN_OPTIN_CHANGED: "WIDGET_UI_SAVE_TOKEN_OPTIN_CHANGED";
        readonly WIDGET_UI_BUTTON_CLICK: "WIDGET_UI_BUTTON_CLICK";
        readonly WIDGET_UI_TOKEN_SELECTED: "WIDGET_UI_TOKEN_SELECTED";
        readonly WIDGET_UI_METHOD_SELECTED: "WIDGET_UI_METHOD_SELECTED";
        readonly WIDGET_UI_TOKEN_UNSELECTED: "WIDGET_UI_TOKEN_UNSELECTED";
        readonly WIDGET_UI_METHOD_UNSELECTED: "WIDGET_UI_METHOD_UNSELECTED";
        readonly WIDGET_UI_PARTNER_ERROR: "WIDGET_UI_PARTNER_ERROR";
        readonly WIDGET_UI_GENERIC_ERROR: "WIDGET_UI_PARTNER_ERROR";
        readonly WIDGET_FIELD_VALIDATED: "WIDGET_FIELD_VALIDATED";
        readonly WIDGET_FIELD_BLUR: "WIDGET_FIELD_BLUR";
        readonly REDIRECTION: "REDIRECTION";
        readonly UNCAUGHT_ERROR: "UNCAUGHT_ERROR";
        readonly PAGE_UNLOAD: "PAGE_UNLOAD";
        readonly HOSTED_FIELDS_CVV_ERROR: "HOSTED_FIELDS_CVV_ERROR";
        readonly HOSTED_FIELDS_CVV_VALID: "HOSTED_FIELDS_CVV_VALID";
        readonly HOSTED_FIELDS_CARD_NUMBER_ERROR: "HOSTED_FIELDS_CARD_NUMBER_ERROR";
        readonly HOSTED_FIELDS_CARD_NUMBER_VALID: "HOSTED_FIELDS_CARD_NUMBER_VALID";
        readonly HOSTED_FIELDS_EXPIRY_DATE_ERROR: "HOSTED_FIELDS_EXPIRY_DATE_ERROR";
        readonly HOSTED_FIELDS_EXPIRY_DATE_VALID: "HOSTED_FIELDS_EXPIRY_DATE_VALID";
        readonly HOSTED_FIELDS_HOLDER_NAME_ERROR: "HOSTED_FIELDS_HOLDER_NAME_ERROR";
        readonly HOSTED_FIELDS_HOLDER_NAME_VALID: "HOSTED_FIELDS_HOLDER_NAME_VALID";
        readonly HOSTED_FIELDS_BIRTH_DATE_ERROR: "HOSTED_FIELDS_BIRTH_DATE_ERROR";
        readonly HOSTED_FIELDS_BIRTH_DATE_VALID: "HOSTED_FIELDS_BIRTH_DATE_VALID";
    };
    static SCOPES: {
        [x: string]: ("CHECKOUT_SESSION_SET" | "CHECKOUT_SESSION_EXPIRED")[] | ("CHECKOUT_PAYMENT_FULFILLED_CHANGES" | "CHECKOUT_PAYMENT_FULLFILLED_ERROR")[] | ("CHECKOUT_VALIDATION_START" | "CHECKOUT_VALIDATION_SUCCEEDED")[] | ("CHECKOUT_VALIDATION_SUCCEEDED" | "CHECKOUT_VALIDATION_FAILED")[] | "WALLET_SESSION_SET"[] | ("WALLET_TOKEN_DELETION_COMPLETE" | "WALLET_ALL_TOKENS_DELETION_COMPLETE")[] | "WIDGET_MANAGER_CREATE"[] | ("WIDGET_CREATE" | "WIDGET_CONFIG_SET")[] | ("WIDGET_UI_TOKEN_SELECTED" | "WIDGET_UI_METHOD_SELECTED" | "WIDGET_UI_TOKEN_UNSELECTED" | "WIDGET_UI_METHOD_UNSELECTED")[] | ("WIDGET_MERGE_NAVIGATION_SELECTION_SKIPPED" | "WIDGET_NAVIGATION_PRIMARY_UPDATE" | "WIDGET_NAVIGATION_SECONDARY_UPDATE" | "WIDGET_MERGE_NAVIGATION_SELECTION_UPDATE" | "WIDGET_MERGE_NAVIGATION_FOCUS_UPDATE" | "WIDGET_MERGE_NAVIGATION_OPEN_UPDATE")[] | ("HOSTED_FIELDS_CVV_ERROR" | "HOSTED_FIELDS_CVV_VALID" | "HOSTED_FIELDS_CARD_NUMBER_ERROR" | "HOSTED_FIELDS_CARD_NUMBER_VALID" | "HOSTED_FIELDS_EXPIRY_DATE_ERROR" | "HOSTED_FIELDS_EXPIRY_DATE_VALID" | "HOSTED_FIELDS_HOLDER_NAME_ERROR" | "HOSTED_FIELDS_HOLDER_NAME_VALID")[] | ("CHECKOUT_API_INIT_FAILED" | "CHECKOUT_SESSION_EXPIRED" | "CHECKOUT_PAYMENT_FULLFILLED_ERROR" | "CHECKOUT_VALIDATION_FAILED" | "CHECKOUT_POST_VALIDATION_FAILED" | "CHECKOUT_PRE_VALIDATION_FAILED" | "WALLET_SESSION_EXPIRED" | "UNCAUGHT_ERROR")[];
    };
    static _instance: CheckoutEventBus | null;
    private constructor();
    postFromCode<Payload = any>(code: string, { type, payload }?: {
        type?: EventType;
        payload?: Payload;
    }): void;
    static getInstance(): CheckoutEventBus;
}
declare class Derived<T, S extends Stores = Stores> implements Subscribable<T>, WithGetter<T> {
    store: Subscribable<T>;
    constructor(stores: S, updater: (values: StoresValues<S>) => T, defaultValue?: T);
    get value(): T;
    getValue(): T;
    subscribe(run: StoreSubscriber<T>, invalidate?: any): Unsubscriber;
}
declare class Environment {
    target: EnvironmentTarget;
    apiKey: string;
    entityId: string;
    constructor(target: EnvironmentTarget, apiKey: string, entityId: string);
}
declare class EventBus<EventType extends Event$1 = Event$1> {
    listeners: {
        [key: string]: EventListener$1<EventType>[];
    };
    history: EventType[];
    queue: EventType[];
    scopes: EventBusScopes;
    private _buses;
    constructor({ scopes }: {
        scopes: EventBusScopes;
    });
    subscribe(listener: EventListener$1<EventType>, scopes?: string[]): EventListenerTerminator;
    unsubscribe(listener: EventListener$1<EventType>, scopes?: string[]): void;
    post(event: EventType): void;
    forwardToBus(bus: EventBus): () => void;
    addScopes(scopes: EventBusScopes): void;
    getReport(): {
        history: EventType[];
    };
    _sort(a: Event$1<any>, b: Event$1<any>): number;
    _processQueue(): void;
    _getListenersForScopes(scopes: string[]): EventListener$1<EventType>[];
    _getScopesForCode(code: string): string[];
}
declare class FetchGatewayAPI extends API implements GatewayAPI {
    overrides?: APIPaths;
    constructor({ environment, apiKey, entityId, beacon, overrides, }: util.Omit<APIConstructor, "root"> & {
        overrides?: APIPaths;
    });
    getServiceRoot(api: keyof APIPaths): string;
    getServerTime(): Promise<APIResponse<ServerDatetime>>;
    private _init;
    init<T = void>(sessionId: string, payload: InitPayload): Promise<APIResponse<InitData<T>>>;
    init3DS<T = void>(sessionId: string, payload: InitPayload): Promise<APIResponse<InitData<T>>>;
    validate(sessionId: string, validateData: ValidationPayload): Promise<APIResponse<ValidationData>>;
    getSimulationsCandidates(body: SimulationCandidatePayload): Promise<APIResponse<SimulationCandidate[]>>;
    getSimulation(partner: string, method: string, body: SimulationCandidatePayload): Promise<APIResponse<SimulationCandidate>>;
    getOwnerTokens(data: {
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
        vault: boolean;
    }): Promise<APIResponse<OwnerTokens>>;
    deleteOwnerToken(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
    }): Promise<APIResponse<void>>;
    deleteOwnerTokenName(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
    }): Promise<APIResponse<void>>;
    editTokenName(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
        name: string;
        reason?: string;
    }): Promise<APIResponse<void>>;
    setOwnerTokenAsFavorite(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
    }): Promise<APIResponse<void>>;
    deleteOwnerTokens(data: {
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
    }): Promise<APIResponse<void>>;
    sendLogs(events: Event$1[], extras?: {
        version?: string;
        paymentSessionId?: string;
        walletSessionId?: string;
        entityId?: string;
        env?: APIEnvironment;
    }): void;
}
declare class ParseStatus {
    value: "aborted" | "dirty" | "valid";
    dirty(): void;
    abort(): void;
    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;
    static mergeObjectAsync(status: ParseStatus, pairs: {
        key: ParseReturnType<any>;
        value: ParseReturnType<any>;
    }[]): Promise<SyncParseReturnType<any>>;
    static mergeObjectSync(status: ParseStatus, pairs: {
        key: SyncParseReturnType<any>;
        value: SyncParseReturnType<any>;
        alwaysSet?: boolean;
    }[]): SyncParseReturnType;
}
declare class PaymentMethod<Actions extends ItemActions = typeof NoopActions> extends PaymentItem$1<PaymentMethodSource, Actions> {
    tokens: Writable<PaymentToken<Actions>[]>;
    constructor({ partner, method, source, actions, }: {
        partner: string;
        method: string;
        source: PaymentMethodSource;
        actions?: PaymentItemActionsBuilder<Actions>;
    });
    get id(): string;
    get isSecondary(): boolean;
    get limit(): number | null;
    get isVault(): boolean;
    deleteToken(id: string): void;
    addToken(token: BuiltSecondaryToken): Promise<PaymentToken<Actions>>;
    static sortByPosition(a: PaymentMethod<any>, b: PaymentMethod<any>): -1 | 0 | 1;
    static getId(partner: string, method: string): string;
    deactivate(): void;
    activate(): void;
}
declare class PaymentSession<Actions extends ItemActions = typeof NoopActions> extends Session<PaymentSessionModel> {
    #private;
    protocols: {
        [partner: string]: {
            [method: string]: PaymentMethod<Actions>;
        };
    };
    tokenList: Readable<PaymentToken<Actions>[]>;
    protocolList: Readable<PaymentMethod<Actions>[]>;
    private _updatedTokens;
    private _deletedTokens;
    constructor(source: PaymentSessionModel, actions?: PaymentItemActionsBuilder<Actions>, serverOffset?: number | null);
    get id(): string;
    get isDataCollection(): boolean;
    get primaries(): Readable<PaymentMethod[]>;
    get secondaries(): Readable<PaymentMethod[]>;
    deleteToken(token: PaymentToken): void;
    editToken(tokenId: string, payload: {
        name: string;
    }): void;
    deleteAllTokens(): void;
    getMethod({ partner, method }: {
        partner?: string;
        method: string;
    }): PaymentMethod<Actions> | null;
    getTokenById(id: string): PaymentToken<Actions> | null;
    private _getProtocolListFromSource;
    private shouldIncludeProtocol;
    private shouldDeleteIntegratedTokens;
}
declare class PaymentToken<Actions extends ItemActions = typeof NoopActions> extends PaymentItem$1<PaymentTokenSource, Actions> {
    private _protocol;
    private _defaultId;
    constructor({ partner, method, protocol, token, actions, }: {
        partner: string;
        method: string;
        protocol: PaymentMethod<Actions>;
        actions?: PaymentItemActionsBuilder<Actions>;
        token: PaymentTokenSource;
    });
    get protocol(): PaymentMethod<Actions> | null;
    get isSecondary(): boolean;
    get id(): string;
    deactivate(): void;
}
declare class PurseHeadlessCheckoutEventBus extends EventBus<PurseHeadlessCheckoutEventBusEvent<any>> {
    static readonly CODES: {
        readonly HEADLESS_CHECKOUT_TOKENS_ARE_DISABLED: "HEADLESS_CHECKOUT_TOKENS_ARE_DISABLED";
        readonly HEADLESS_CHECKOUT_READY: "HEADLESS_CHECKOUT_READY";
        readonly HEADLESS_CHECKOUT_EXPIRED_SESSION: "HEADLESS_CHECKOUT_EXPIRED_SESSION";
        readonly HEADLESS_CHECKOUT_PAYMENT_FULFILLED: "HEADLESS_CHECKOUT_PAYMENT_FULFILLED";
        readonly HEADLESS_CHECKOUT_OTHER_ERROR: "HEADLESS_CHECKOUT_OTHER_ERROR";
        readonly HEADLESS_CHECKOUT_PAYMENT_ERROR: "HEADLESS_CHECKOUT_PAYMENT_ERROR";
    };
    static readonly SCOPES: {
        headlessCheckout: ("HEADLESS_CHECKOUT_READY" | "HEADLESS_CHECKOUT_EXPIRED_SESSION" | "HEADLESS_CHECKOUT_PAYMENT_FULFILLED" | "HEADLESS_CHECKOUT_OTHER_ERROR" | "HEADLESS_CHECKOUT_PAYMENT_ERROR")[];
    };
    private static _instance;
    constructor();
    post<T>(event: PurseHeadlessCheckoutEventBusEvent<T>): void;
    unsubscribeAll(): void;
    subscribe(listener: EventListener$1<PurseHeadlessCheckoutEventBusEvent<any>>, scopes?: Array<keyof typeof EventScopes | "*">): EventListenerTerminator;
    postFromCode<T>(code: keyof typeof PurseHeadlessCheckoutEventBusCodesEnum, { type, payload, }?: {
        type?: EventType;
        payload?: T;
    }): void;
}
declare class Wallet<Actions extends ItemActions = WalletActions> {
    #private;
    session?: WalletSession<Actions>;
    api: FetchGatewayAPI;
    private env;
    private _currentActionBuilder?;
    private _sessionExpiredUnsub?;
    eventBus: WalletEventBus;
    constructor({ apiKey, entityId, environment, paymentItemActionsBuilder, rootOverrides, }: {
        apiKey: string;
        entityId: string;
        environment: EnvironmentTarget;
        paymentItemActionsBuilder?: PaymentItemActionsBuilder<Actions>;
        rootOverrides?: APIPaths;
    });
    get _actionBuilder(): PaymentItemActionsBuilder<Actions> | undefined;
    set _actionBuilder(builder: PaymentItemActionsBuilder<Actions> | undefined);
    setSession({ session, actionBuilder, onExpires, }: {
        session: WalletSessionModel;
        actionBuilder?: PaymentItemActionsBuilder<Actions>;
        onExpires?: () => void;
    }): Promise<Wallet<Actions>>;
    deleteAllTokensFromWallet(): Promise<void>;
    deleteTokenFromWallet(token: PaymentToken<any>): Promise<void>;
    editTokenName(token: PaymentToken<any>, payload: {
        name: string;
    }): Promise<void>;
    private setServerTimeOffset;
    private verifySessionExpiration;
    private _onSessionValidityChanges;
}
declare class WalletActions implements ItemActions {
    method: PaymentMethod<WalletActions>;
    token?: PaymentToken<WalletActions>;
    wallet: Wallet<WalletActions>;
    isFavorite: Readable<boolean>;
    name: Writable<string | null>;
    constructor({ method, token, wallet, }: {
        method: PaymentMethod<WalletActions>;
        token?: PaymentToken<WalletActions>;
        wallet: Wallet<WalletActions>;
    });
    canBeModifiedFromWallet(): boolean;
    setAsFavorite(): Promise<void>;
    preValidate(payload: {
        amount: number;
    } & PaymentItemData): Promise<void>;
    postValidate(validation: {
        validation: ValidationData;
        result: ItemValidationData;
    }): Promise<boolean>;
    buildData(): {};
    deleteFromWallet(): Promise<void>;
    editTokenName(payload: {
        name: string;
    }): Promise<void>;
}
declare class WalletEvent<Payload = any> implements Event$1<Payload> {
    code: string;
    dateString: string;
    type: EventType;
    payload?: Payload;
    constructor({ code, payload, type }: {
        code: string;
        type?: EventType;
        payload?: Payload;
    });
}
declare class WalletEventBus extends EventBus<WalletEvent> {
    static CODES: {
        readonly CHECKOUT_SESSION_SET: "CHECKOUT_SESSION_SET";
        readonly CHECKOUT_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME: "CHECKOUT_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME";
        readonly CHECKOUT_SESSION_EXPIRED: "CHECKOUT_SESSION_EXPIRED";
        readonly CHECKOUT_VALIDATION_START: "CHECKOUT_VALIDATION_START";
        readonly CHECKOUT_API_START: "CHECKOUT_API_START";
        readonly CHECKOUT_API_END: "CHECKOUT_API_END";
        readonly CHECKOUT_API_INIT_SUCCEEDED: "CHECKOUT_API_INIT_SUCCEEDED";
        readonly CHECKOUT_API_INIT_FAILED: "CHECKOUT_API_INIT_FAILED";
        readonly CHECKOUT_API_VALIDATION_SUCCEEDED: "CHECKOUT_API_VALIDATION_SUCCEEDED";
        readonly CHECKOUT_POST_VALIDATION_SUCCEEDED: "CHECKOUT_POST_VALIDATION_SUCCEEDED";
        readonly CHECKOUT_POST_VALIDATION_FAILED: "CHECKOUT_POST_VALIDATION_FAILED";
        readonly CHECKOUT_VALIDATION_SUCCEEDED: "CHECKOUT_VALIDATION_SUCCEEDED";
        readonly CHECKOUT_VALIDATION_FAILED: "CHECKOUT_VALIDATION_FAILED";
        readonly CHECKOUT_INTERNAL_3DS_STEP: "CHECKOUT_INTERNAL_3DS_STEP";
        readonly CHECKOUT_PRE_VALIDATION_FAILED: "CHECKOUT_PRE_VALIDATION_FAILED";
        readonly CHECKOUT_PRE_VALIDATION_ALREADY_ROLLING: "CHECKOUT_PRE_VALIDATION_ALREADY_ROLLING";
        readonly CHECKOUT_PRE_VALIDATION_STARTING: "CHECKOUT_PRE_VALIDATION_STARTING";
        readonly CHECKOUT_PAYMENT_FULFILLED_CHANGES: "CHECKOUT_PAYMENT_FULFILLED_CHANGES";
        readonly CHECKOUT_PAYMENT_FULLFILLED_ERROR: "CHECKOUT_PAYMENT_FULLFILLED_ERROR";
        readonly WALLET_SESSION_SET: "WALLET_SESSION_SET";
        readonly WALLET_SESSION_EXPIRED: "WALLET_SESSION_EXPIRED";
        readonly WALLET_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME: "WALLET_SESSION_EXPIRATION_BACKED_BY_SERVER_TIME";
        readonly WALLET_TOKEN_DELETION_COMPLETE: "WALLET_TOKEN_DELETION_COMPLETE";
        readonly WALLET_TOKEN_EDITION_COMPLETE: "WALLET_TOKEN_EDITION_COMPLETE";
        readonly WALLET_ALL_TOKENS_DELETION_COMPLETE: "WALLET_ALL_TOKENS_DELETION_COMPLETE";
        readonly WALLET_TOKEN_SET_AS_FAVORITE: "WALLET_TOKEN_SET_AS_FAVORITE";
        readonly WIDGET_MANAGER_CREATE: "WIDGET_MANAGER_CREATE";
        readonly WIDGET_MANAGER_ANALYTICS: "WIDGET_MANAGER_ANALYTICS";
        readonly WIDGET_MANAGER_SUBMIT_PAYMENT: "WIDGET_MANAGER_SUBMIT_PAYMENT";
        readonly WIDGET_SUBMIT_PAYMENT: "WIDGET_SUBMIT_PAYMENT";
        readonly WIDGET_GET_PLUGIN_FAILED: "WIDGET_GET_PLUGIN_FAILED";
        readonly WIDGET_PROTOCOL_UNSTABLE_FILTER: "WIDGET_PROTOCOL_UNSTABLE_FILTER";
        readonly WIDGET_PROTOCOL_PLUGIN_NOT_IMPLEMENTED: "WIDGET_PROTOCOL_PLUGIN_NOT_IMPLEMENTED";
        readonly WIDGET_CREATE: "WIDGET_CREATE";
        readonly WIDGET_MOUNTED: "WIDGET_MOUNTED";
        readonly WIDGET_UNMOUNTED: "WIDGET_UNMOUNTED";
        readonly WIDGET_FETCH_CONFIG_FAILED_SOFTLY: "WIDGET_FETCH_CONFIG_FAILED_SOFTLY";
        readonly WIDGET_CONFIG_NAME_IS_MANDATORY_SHOULD_BE_UNIQUE: "WIDGET_CONFIG_NAME_IS_MANDATORY_SHOULD_BE_UNIQUE";
        readonly WIDGET_CONFIG_SET: "WIDGET_CONFIG_SET";
        readonly WIDGET_MERGE_NAVIGATION_SELECTION_UPDATE: "WIDGET_MERGE_NAVIGATION_SELECTION_UPDATE";
        readonly WIDGET_MERGE_NAVIGATION_SELECTION_SKIPPED: "WIDGET_MERGE_NAVIGATION_SELECTION_SKIPPED";
        readonly WIDGET_MERGE_NAVIGATION_FOCUS_UPDATE: "WIDGET_MERGE_NAVIGATION_FOCUS_UPDATE";
        readonly WIDGET_MERGE_NAVIGATION_TRY_TO_SELECT_SUSPENDED_ITEM: "WIDGET_MERGE_NAVIGATION_TRY_TO_SELECT_SUSPENDED_ITEM";
        readonly WIDGET_MERGE_NAVIGATION_SELECTED_ITEM_IS_NOW_SUSPENDED: "WIDGET_MERGE_NAVIGATION_SELECTED_ITEM_IS_NOW_SUSPENDED";
        readonly WIDGET_MERGE_NAVIGATION_OPEN_UPDATE: "WIDGET_MERGE_NAVIGATION_OPEN_UPDATE";
        readonly WIDGET_NAVIGATION_PRIMARY_UPDATE: "WIDGET_NAVIGATION_PRIMARY_UPDATE";
        readonly WIDGET_NAVIGATION_SECONDARY_UPDATE: "WIDGET_NAVIGATION_SECONDARY_UPDATE";
        readonly WIDGET_SUBMISSION_AFTER_PARTNER_SDK_REJECTION: "WIDGET_SUBMISSION_AFTER_PARTNER_SDK_REJECTION";
        readonly WIDGET_UI_SAVE_TOKEN_OPTIN_CHANGED: "WIDGET_UI_SAVE_TOKEN_OPTIN_CHANGED";
        readonly WIDGET_UI_BUTTON_CLICK: "WIDGET_UI_BUTTON_CLICK";
        readonly WIDGET_UI_TOKEN_SELECTED: "WIDGET_UI_TOKEN_SELECTED";
        readonly WIDGET_UI_METHOD_SELECTED: "WIDGET_UI_METHOD_SELECTED";
        readonly WIDGET_UI_TOKEN_UNSELECTED: "WIDGET_UI_TOKEN_UNSELECTED";
        readonly WIDGET_UI_METHOD_UNSELECTED: "WIDGET_UI_METHOD_UNSELECTED";
        readonly WIDGET_UI_PARTNER_ERROR: "WIDGET_UI_PARTNER_ERROR";
        readonly WIDGET_UI_GENERIC_ERROR: "WIDGET_UI_PARTNER_ERROR";
        readonly WIDGET_FIELD_VALIDATED: "WIDGET_FIELD_VALIDATED";
        readonly WIDGET_FIELD_BLUR: "WIDGET_FIELD_BLUR";
        readonly REDIRECTION: "REDIRECTION";
        readonly UNCAUGHT_ERROR: "UNCAUGHT_ERROR";
        readonly PAGE_UNLOAD: "PAGE_UNLOAD";
        readonly HOSTED_FIELDS_CVV_ERROR: "HOSTED_FIELDS_CVV_ERROR";
        readonly HOSTED_FIELDS_CVV_VALID: "HOSTED_FIELDS_CVV_VALID";
        readonly HOSTED_FIELDS_CARD_NUMBER_ERROR: "HOSTED_FIELDS_CARD_NUMBER_ERROR";
        readonly HOSTED_FIELDS_CARD_NUMBER_VALID: "HOSTED_FIELDS_CARD_NUMBER_VALID";
        readonly HOSTED_FIELDS_EXPIRY_DATE_ERROR: "HOSTED_FIELDS_EXPIRY_DATE_ERROR";
        readonly HOSTED_FIELDS_EXPIRY_DATE_VALID: "HOSTED_FIELDS_EXPIRY_DATE_VALID";
        readonly HOSTED_FIELDS_HOLDER_NAME_ERROR: "HOSTED_FIELDS_HOLDER_NAME_ERROR";
        readonly HOSTED_FIELDS_HOLDER_NAME_VALID: "HOSTED_FIELDS_HOLDER_NAME_VALID";
        readonly HOSTED_FIELDS_BIRTH_DATE_ERROR: "HOSTED_FIELDS_BIRTH_DATE_ERROR";
        readonly HOSTED_FIELDS_BIRTH_DATE_VALID: "HOSTED_FIELDS_BIRTH_DATE_VALID";
    };
    static SCOPES: {
        [x: string]: ("CHECKOUT_SESSION_SET" | "CHECKOUT_SESSION_EXPIRED")[] | ("CHECKOUT_PAYMENT_FULFILLED_CHANGES" | "CHECKOUT_PAYMENT_FULLFILLED_ERROR")[] | ("CHECKOUT_VALIDATION_START" | "CHECKOUT_VALIDATION_SUCCEEDED")[] | ("CHECKOUT_VALIDATION_SUCCEEDED" | "CHECKOUT_VALIDATION_FAILED")[] | "WALLET_SESSION_SET"[] | ("WALLET_TOKEN_DELETION_COMPLETE" | "WALLET_ALL_TOKENS_DELETION_COMPLETE")[] | "WIDGET_MANAGER_CREATE"[] | ("WIDGET_CREATE" | "WIDGET_CONFIG_SET")[] | ("WIDGET_UI_TOKEN_SELECTED" | "WIDGET_UI_METHOD_SELECTED" | "WIDGET_UI_TOKEN_UNSELECTED" | "WIDGET_UI_METHOD_UNSELECTED")[] | ("WIDGET_MERGE_NAVIGATION_SELECTION_SKIPPED" | "WIDGET_NAVIGATION_PRIMARY_UPDATE" | "WIDGET_NAVIGATION_SECONDARY_UPDATE" | "WIDGET_MERGE_NAVIGATION_SELECTION_UPDATE" | "WIDGET_MERGE_NAVIGATION_FOCUS_UPDATE" | "WIDGET_MERGE_NAVIGATION_OPEN_UPDATE")[] | ("HOSTED_FIELDS_CVV_ERROR" | "HOSTED_FIELDS_CVV_VALID" | "HOSTED_FIELDS_CARD_NUMBER_ERROR" | "HOSTED_FIELDS_CARD_NUMBER_VALID" | "HOSTED_FIELDS_EXPIRY_DATE_ERROR" | "HOSTED_FIELDS_EXPIRY_DATE_VALID" | "HOSTED_FIELDS_HOLDER_NAME_ERROR" | "HOSTED_FIELDS_HOLDER_NAME_VALID")[] | ("CHECKOUT_SESSION_EXPIRED" | "CHECKOUT_PAYMENT_FULLFILLED_ERROR" | "CHECKOUT_VALIDATION_FAILED" | "CHECKOUT_API_INIT_FAILED" | "CHECKOUT_POST_VALIDATION_FAILED" | "CHECKOUT_PRE_VALIDATION_FAILED" | "WALLET_SESSION_EXPIRED" | "UNCAUGHT_ERROR")[];
    };
    static _instance: WalletEventBus;
    private constructor();
    postFromCode<Payload = any>(code: string, { type, payload }?: {
        type?: EventType;
        payload?: Payload;
    }): void;
    static getInstance(): WalletEventBus;
}
declare class WalletSession<Actions extends ItemActions = typeof NoopActions> extends Session<WalletSessionModel> {
    tokenList: Writable<PaymentToken<Actions>[]>;
    favoriteToken: Writable<PaymentToken<Actions>>;
    _actionsBuilder?: PaymentItemActionsBuilder<Actions>;
    constructor(source: WalletSessionModel, actions?: PaymentItemActionsBuilder<Actions>, serverOffset?: number | null);
    get id(): string;
    getToken(id: string): PaymentToken<Actions> | undefined;
    deleteToken(token: PaymentToken<Actions>): Writable<PaymentToken<Actions>[]>;
    deleteTokens(): void;
    setFavoriteToken(token: PaymentToken<Actions>): void;
    setTokens(tokens: IntegratedToken[]): void;
}
declare class Writable<T> implements Subscribable<T>, WithGetter<T>, SvelteWritable<T> {
    store: SvelteWritable<T>;
    constructor(defaultValue?: T);
    get value(): T;
    set value(value: T);
    getValue(): T;
    subscribe(listener: Subscriber<T>, invalidate?: any): Unsubscriber;
    set(value: T): void;
    update(updater: StoreUpdater<T>): Writable<T>;
    patchStore(patch: any): Writable<T>;
}
declare class ZodAny extends ZodType<any, ZodAnyDef, any> {
    _any: true;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: (params?: RawCreateParams) => ZodAny;
}
declare class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends "atleastone" ? [
    T["_input"],
    ...T["_input"][]
] : T["_input"][]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get element(): T;
    min(minLength: number, message?: errorUtil.ErrMessage): this;
    max(maxLength: number, message?: errorUtil.ErrMessage): this;
    length(len: number, message?: errorUtil.ErrMessage): this;
    nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone">;
    static create: <El extends ZodTypeAny>(schema: El, params?: RawCreateParams) => ZodArray<El>;
}
declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef, boolean> {
    _parse(input: ParseInput): ParseReturnType<boolean>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodBoolean;
}
declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T["_output"] & BRAND<B>, ZodBrandedDef<T>, T["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    unwrap(): T;
}
declare class ZodCatch<T extends ZodTypeAny> extends ZodType<T["_output"], ZodCatchDef<T>, unknown> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeCatch(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params: RawCreateParams & {
        catch: Inner["_output"] | (() => Inner["_output"]);
    }) => ZodCatch<Inner>;
}
declare class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T["_output"]>, ZodDefaultDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    removeDefault(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params: RawCreateParams & {
        default: Inner["_input"] | (() => util.noUndefined<Inner["_input"]>);
    }) => ZodDefault<Inner>;
}
declare class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {
    innerType(): T;
    sourceType(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"]>;
    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
}
declare class ZodEnum<T extends [
    string,
    ...string[]
]> extends ZodType<T[number], ZodEnumDef<T>, T[number]> {
    _cache: Set<T[number]> | undefined;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    get enum(): Values<T>;
    get Values(): Values<T>;
    get Enum(): Values<T>;
    extract<ToExtract extends readonly [
        T[number],
        ...T[number][]
    ]>(values: ToExtract, newDef?: RawCreateParams): ZodEnum<Writeable<ToExtract>>;
    exclude<ToExclude extends readonly [
        T[number],
        ...T[number][]
    ]>(values: ToExclude, newDef?: RawCreateParams): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [
        string,
        ...string[]
    ]>>;
    static create: typeof createZodEnum;
}
declare class ZodError<T = any> extends Error {
    issues: ZodIssue[];
    get errors(): ZodIssue[];
    constructor(issues: ZodIssue[]);
    format(): ZodFormattedError<T>;
    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;
    static create: (issues: ZodIssue[]) => ZodError<any>;
    static assert(value: unknown): asserts value is ZodError;
    toString(): string;
    get message(): string;
    get isEmpty(): boolean;
    addIssue: (sub: ZodIssue) => void;
    addIssues: (subs?: ZodIssue[]) => void;
    flatten(): typeToFlattenedError<T>;
    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;
    get formErrors(): typeToFlattenedError<T, string>;
}
declare class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T["_output"] & U["_output"], ZodIntersectionDef<T, U>, T["_input"] & U["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <TSchema extends ZodTypeAny, USchema extends ZodTypeAny>(left: TSchema, right: USchema, params?: RawCreateParams) => ZodIntersection<TSchema, USchema>;
}
declare class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>, T[keyof T]> {
    _cache: Set<T[keyof T]> | undefined;
    _parse(input: ParseInput): ParseReturnType<T[keyof T]>;
    get enum(): T;
    static create: <Elements extends EnumLike>(values: Elements, params?: RawCreateParams) => ZodNativeEnum<Elements>;
}
declare class ZodNullable<T extends ZodTypeAny> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams) => ZodNullable<Inner>;
}
declare class ZodNumber extends ZodType<number, ZodNumberDef, number> {
    _parse(input: ParseInput): ParseReturnType<number>;
    static create: (params?: RawCreateParams & {
        coerce?: boolean;
    }) => ZodNumber;
    gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    min: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    max: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    protected setLimit(kind: "min" | "max", value: number, inclusive: boolean, message?: string): ZodNumber;
    _addCheck(check: ZodNumberCheck): ZodNumber;
    int(message?: errorUtil.ErrMessage): ZodNumber;
    positive(message?: errorUtil.ErrMessage): ZodNumber;
    negative(message?: errorUtil.ErrMessage): ZodNumber;
    nonpositive(message?: errorUtil.ErrMessage): ZodNumber;
    nonnegative(message?: errorUtil.ErrMessage): ZodNumber;
    multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;
    step: (value: number, message?: errorUtil.ErrMessage) => ZodNumber;
    finite(message?: errorUtil.ErrMessage): ZodNumber;
    safe(message?: errorUtil.ErrMessage): ZodNumber;
    get minValue(): number | null;
    get maxValue(): number | null;
    get isInt(): boolean;
    get isFinite(): boolean;
}
declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall, UnknownKeys>, Input = objectInputType<T, Catchall, UnknownKeys>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
    private _cached;
    _getCached(): {
        shape: T;
        keys: string[];
    };
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get shape(): T;
    strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall>;
    strip(): ZodObject<T, "strip", Catchall>;
    passthrough(): ZodObject<T, "passthrough", Catchall>;
    /**
     * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.
     * If you want to pass through unknown properties, use `.passthrough()` instead.
     */
    nonstrict: () => ZodObject<T, "passthrough", Catchall>;
    extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * @deprecated Use `.extend` instead
     *  */
    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge<Incoming extends AnyZodObject, Augmentation extends Incoming["shape"]>(merging: Incoming): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming["_def"]["unknownKeys"], Incoming["_def"]["catchall"]>;
    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {
        [k in Key]: Schema;
    }, UnknownKeys, Catchall>;
    catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;
    pick<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;
    omit<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;
    /**
     * @deprecated
     */
    deepPartial(): partialUtil.DeepPartial<this>;
    partial(): ZodObject<{
        [k in keyof T]: ZodOptional<T[k]>;
    }, UnknownKeys, Catchall>;
    partial<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    required(): ZodObject<{
        [k in keyof T]: deoptional<T[k]>;
    }, UnknownKeys, Catchall>;
    required<Mask extends util.Exactly<{
        [k in keyof T]?: true;
    }, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
    }>, UnknownKeys, Catchall>;
    keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;
    static create: <Shape extends ZodRawShape>(shape: Shape, params?: RawCreateParams) => ZodObject<Shape, "strip", ZodTypeAny, objectOutputType<Shape, ZodTypeAny, "strip">, objectInputType<Shape, ZodTypeAny, "strip">>;
    static strictCreate: <Shape extends ZodRawShape>(shape: Shape, params?: RawCreateParams) => ZodObject<Shape, "strict">;
    static lazycreate: <Shape extends ZodRawShape>(shape: () => Shape, params?: RawCreateParams) => ZodObject<Shape, "strip">;
}
declare class ZodOptional<T extends ZodTypeAny> extends ZodType<T["_output"] | undefined, ZodOptionalDef<T>, T["_input"] | undefined> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    unwrap(): T;
    static create: <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams) => ZodOptional<Inner>;
}
declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B["_output"], ZodPipelineDef<A, B>, A["_input"]> {
    _parse(input: ParseInput): ParseReturnType<any>;
    static create<ASchema extends ZodTypeAny, BSchema extends ZodTypeAny>(a: ASchema, b: BSchema): ZodPipeline<ASchema, BSchema>;
}
declare class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T["_output"]>, ZodPromiseDef<T>, Promise<T["_input"]>> {
    unwrap(): T;
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <Inner extends ZodTypeAny>(schema: Inner, params?: RawCreateParams) => ZodPromise<Inner>;
}
declare class ZodReadonly<T extends ZodTypeAny> extends ZodType<MakeReadonly<T["_output"]>, ZodReadonlyDef<T>, MakeReadonly<T["_input"]>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    static create: <Inner extends ZodTypeAny>(type: Inner, params?: RawCreateParams) => ZodReadonly<Inner>;
    unwrap(): T;
}
declare class ZodString extends ZodType<string, ZodStringDef, string> {
    _parse(input: ParseInput): ParseReturnType<string>;
    protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage): ZodEffects<this, string, string>;
    _addCheck(check: ZodStringCheck): ZodString;
    email(message?: errorUtil.ErrMessage): ZodString;
    url(message?: errorUtil.ErrMessage): ZodString;
    emoji(message?: errorUtil.ErrMessage): ZodString;
    uuid(message?: errorUtil.ErrMessage): ZodString;
    nanoid(message?: errorUtil.ErrMessage): ZodString;
    cuid(message?: errorUtil.ErrMessage): ZodString;
    cuid2(message?: errorUtil.ErrMessage): ZodString;
    ulid(message?: errorUtil.ErrMessage): ZodString;
    base64(message?: errorUtil.ErrMessage): ZodString;
    base64url(message?: errorUtil.ErrMessage): ZodString;
    jwt(options?: {
        alg?: string;
        message?: string | undefined;
    }): ZodString;
    ip(options?: string | {
        version?: IpVersion;
        message?: string | undefined;
    }): ZodString;
    cidr(options?: string | {
        version?: IpVersion;
        message?: string | undefined;
    }): ZodString;
    datetime(options?: string | {
        message?: string | undefined;
        precision?: number | null;
        offset?: boolean;
        local?: boolean;
    }): ZodString;
    date(message?: string): ZodString;
    time(options?: string | {
        message?: string | undefined;
        precision?: number | null;
    }): ZodString;
    duration(message?: errorUtil.ErrMessage): ZodString;
    regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;
    includes(value: string, options?: {
        message?: string;
        position?: number;
    }): ZodString;
    startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;
    min(minLength: number, message?: errorUtil.ErrMessage): ZodString;
    max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;
    length(len: number, message?: errorUtil.ErrMessage): ZodString;
    /**
     * Equivalent to `.min(1)`
     */
    nonempty(message?: errorUtil.ErrMessage): ZodString;
    trim(): ZodString;
    toLowerCase(): ZodString;
    toUpperCase(): ZodString;
    get isDatetime(): boolean;
    get isDate(): boolean;
    get isTime(): boolean;
    get isDuration(): boolean;
    get isEmail(): boolean;
    get isURL(): boolean;
    get isEmoji(): boolean;
    get isUUID(): boolean;
    get isNANOID(): boolean;
    get isCUID(): boolean;
    get isCUID2(): boolean;
    get isULID(): boolean;
    get isIP(): boolean;
    get isCIDR(): boolean;
    get isBase64(): boolean;
    get isBase64url(): boolean;
    get minLength(): number | null;
    get maxLength(): number | null;
    static create: (params?: RawCreateParams & {
        coerce?: true;
    }) => ZodString;
}
declare class ZodTuple<T extends ZodTupleItems | [
] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get items(): T;
    rest<RestSchema extends ZodTypeAny>(rest: RestSchema): ZodTuple<T, RestSchema>;
    static create: <Items extends [
        ZodTypeAny,
        ...ZodTypeAny[]
    ] | [
    ]>(schemas: Items, params?: RawCreateParams) => ZodTuple<Items, null>;
}
declare class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
    _parse(input: ParseInput): ParseReturnType<this["_output"]>;
    get options(): T;
    static create: <Options extends Readonly<[
        ZodTypeAny,
        ZodTypeAny,
        ...ZodTypeAny[]
    ]>>(types: Options, params?: RawCreateParams) => ZodUnion<Options>;
}
declare const BRAND: unique symbol;
declare const CardBrandEnum: {
    readonly CARTE_BANCAIRE: "CARTE_BANCAIRE";
    readonly VISA: "VISA";
    readonly MASTERCARD: "MASTERCARD";
    readonly AMERICAN_EXPRESS: "AMERICAN_EXPRESS";
    readonly MAESTRO: "MAESTRO";
};
declare const CardSchemes: {
    readonly CARTE_BANCAIRE: "CARTE_BANCAIRE";
    readonly VISA: "VISA";
    readonly MASTERCARD: "MASTERCARD";
    readonly AMERICAN_EXPRESS: "AMERICAN_EXPRESS";
    readonly MAESTRO: "MAESTRO";
    readonly ONEY: "ONEY";
};
declare const DIRTY: <T>(value: T) => DIRTY<T>;
declare const Environments: readonly [
    "development",
    "test",
    "sandbox",
    "production"
];
declare const EventScopes: {
    headlessCheckout: ("HEADLESS_CHECKOUT_READY" | "HEADLESS_CHECKOUT_EXPIRED_SESSION" | "HEADLESS_CHECKOUT_PAYMENT_FULFILLED" | "HEADLESS_CHECKOUT_OTHER_ERROR" | "HEADLESS_CHECKOUT_PAYMENT_ERROR")[];
};
declare const Events: {
    readonly clientError: {
        readonly code: "clientError";
        readonly topics: readonly [
            "lethal"
        ];
    };
    readonly clientNotFound: {
        readonly code: "clientNotFound";
        readonly topics: readonly [
            "lethal"
        ];
    };
    readonly cantDownloadPluginSources: {
        readonly code: "cantDownloadPluginSources";
        readonly topics: readonly [
            "lethal"
        ];
    };
    readonly disconnected: {
        readonly code: "disconnected";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly died: {
        readonly code: "died";
        readonly topics: readonly [
            "lethal"
        ];
    };
    readonly fulfilled: {
        readonly code: "fulfilled";
        readonly topics: readonly [
            "info",
            "fulfilled"
        ];
    };
    readonly initFailed: {
        readonly code: "initFailed";
        readonly topics: readonly [
            "lethal"
        ];
    };
    readonly misconfigured: {
        readonly code: "misconfigured";
        readonly topics: readonly [
            "lethal"
        ];
    };
    readonly modalIn: {
        readonly code: "modalIn";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly modalOut: {
        readonly code: "modalOut";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly optionsSet: {
        readonly code: "optionsSet";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginClientDestroyed: {
        readonly code: "pluginClientDestroyed";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginExtraSourcesLoaded: {
        readonly code: "pluginExtraSourcesLoaded";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginPostValidation: {
        readonly code: "pluginPostValidation";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginPreValidation: {
        readonly code: "pluginPreValidation";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginSessionSet: {
        readonly code: "pluginSessionSet";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginSourcesLoaded: {
        readonly code: "pluginSourcesLoaded";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly pluginIsIncompatibleWithClient: {
        readonly code: "pluginIsIncompatibleWithClient";
        readonly topics: readonly [
            "error"
        ];
    };
    readonly ready: {
        readonly code: "ready";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly redirect: {
        readonly code: "redirect";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly requestValidate: {
        readonly code: "requestValidate";
        readonly topics: readonly [
            "requestValidate"
        ];
    };
    readonly sourceListLoaded: {
        readonly code: "sourceListLoaded";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly sourceLoaded: {
        readonly code: "sourceLoaded";
        readonly topics: readonly [
            "info"
        ];
    };
    readonly other: {
        readonly code: "other";
        readonly topics: readonly [
            "info"
        ];
    };
};
declare const INVALID: INVALID;
declare const InitData: ZodObject<{
    id: ZodString;
    session_id: ZodOptional<ZodString>;
    date: ZodString;
    method: ZodString;
    partner: ZodString;
    step_id: ZodNumber;
    status: ZodObject<{
        action: ZodNativeEnum<typeof TransactionAction>;
        state: ZodNativeEnum<typeof StatusState>;
        description: ZodOptional<ZodString>;
        code: ZodNativeEnum<typeof StatusCode>;
    }, "strip", ZodTypeAny, {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    }, {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    }>;
    plugin_result: ZodAny;
}, "strip", ZodTypeAny, {
    status: {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    };
    date: string;
    method: string;
    partner: string;
    step_id: number;
    id: string;
    session_id?: string | undefined;
    plugin_result?: any;
}, {
    status: {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    };
    date: string;
    method: string;
    partner: string;
    step_id: number;
    id: string;
    session_id?: string | undefined;
    plugin_result?: any;
}>;
declare const InitPayload: ZodObject<{
    method: ZodString;
    partner: ZodString;
    amount: ZodNumber;
    paymentData: ZodAny;
    partnerData: ZodAny;
    order: ZodAny;
    paymentPreferences: ZodAny;
    step_id: ZodOptional<ZodNumber>;
}, "strip", ZodTypeAny, {
    method: string;
    partner: string;
    amount: number;
    paymentData?: any;
    partnerData?: any;
    order?: any;
    paymentPreferences?: any;
    step_id?: number | undefined;
}, {
    method: string;
    partner: string;
    amount: number;
    paymentData?: any;
    partnerData?: any;
    order?: any;
    paymentPreferences?: any;
    step_id?: number | undefined;
}>;
declare const IntegrationTypes: {
    readonly hostedForm: "hostedForm";
    readonly xPayButton: "xPayButton";
    readonly redirection: "redirection";
};
declare const ItemValidationData: ZodObject<{
    id: ZodString;
    date: ZodString;
    method: ZodString;
    partner: ZodString;
    session_id: ZodString;
    transaction_id: ZodString;
    plugin_result: ZodAny;
    status: ZodObject<{
        action: ZodNativeEnum<typeof TransactionAction>;
        state: ZodNativeEnum<typeof StatusState>;
        description: ZodOptional<ZodString>;
        code: ZodNativeEnum<typeof StatusCode>;
    }, "strip", ZodTypeAny, {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    }, {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    }>;
}, "strip", ZodTypeAny, {
    status: {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    };
    date: string;
    method: string;
    partner: string;
    id: string;
    session_id: string;
    transaction_id: string;
    plugin_result?: any;
}, {
    status: {
        action: TransactionAction;
        code: StatusCode;
        state: StatusState;
        description?: string | undefined;
    };
    date: string;
    method: string;
    partner: string;
    id: string;
    session_id: string;
    transaction_id: string;
    plugin_result?: any;
}>;
declare const Methods: {
    readonly applepay: "applepay";
    readonly bancontact: "bancontact";
    readonly bizum: "bizum";
    readonly bnpl: "bnpl";
    readonly buybox: "buybox";
    readonly cb10x: "cb10x";
    readonly cb10xsansfrais: "cb10xsansfrais";
    readonly cb12x: "cb12x";
    readonly cb12xsansfrais: "cb12xsansfrais";
    readonly cb2x: "cb2x";
    readonly cb3x: "cb3x";
    readonly cb3xsansfrais: "cb3xsansfrais";
    readonly cb4x: "cb4x";
    readonly cb4xsansfrais: "cb4xsansfrais";
    readonly comptant: "comptant";
    readonly creditcard: "creditcard";
    readonly googlepay: "googlepay";
    readonly ideal: "ideal";
    readonly installments: "installments";
    readonly instantpayment: "instantpayment";
    readonly invoice: "invoice";
    readonly loan: "loan";
    readonly maxxing: "maxxing";
    readonly mbway: "mbway";
    readonly multibanco: "multibanco";
    readonly paybylink: "paybylink";
    readonly paylater: "paylater";
    readonly paypal: "paypal";
    readonly revolving: "revolving";
    readonly sepa: "sepa";
    readonly sdd: "sdd";
    readonly sepainstant: "sepainstant";
    readonly separecurrent: "separecurrent";
    readonly sepasingle: "sepasingle";
    readonly slimcollect: "slimcollect";
    readonly smart_transfer: "smart_transfer";
    readonly twint: "twint";
    readonly wallet: "wallet";
};
declare const NoopActions: {
    buildData: () => {};
};
declare const OK: <T>(value: T) => OK<T>;
declare const PartnerPayload: ZodObject<{
    method: ZodString;
    partner: ZodString;
    amount: ZodNumber;
    paymentData: ZodAny;
    partnerData: ZodAny;
    order: ZodAny;
    paymentPreferences: ZodAny;
    step_id: ZodOptional<ZodNumber>;
}, "strip", ZodTypeAny, {
    method: string;
    partner: string;
    amount: number;
    paymentData?: any;
    partnerData?: any;
    order?: any;
    paymentPreferences?: any;
    step_id?: number | undefined;
}, {
    method: string;
    partner: string;
    amount: number;
    paymentData?: any;
    partnerData?: any;
    order?: any;
    paymentPreferences?: any;
    step_id?: number | undefined;
}>;
declare const Partners: {
    readonly aci: "aci";
    readonly adyen: "adyen";
    readonly alma: "alma";
    readonly axepta: "axepta";
    readonly braintree: "braintree";
    readonly centralpay: "centralpay";
    readonly checkout: "checkout";
    readonly cofidis: "cofidis";
    readonly dalenys: "dalenys";
    readonly easycollect: "easycollect";
    readonly fintecture: "fintecture";
    readonly floa: "floa";
    readonly gocardless: "gocardless";
    readonly hipay: "hipay";
    readonly ingenico: "ingenico";
    readonly klarna: "klarna";
    readonly mercanet: "mercanet";
    readonly oney: "oney";
    readonly oneycard: "oneycard";
    readonly paybox: "paybox";
    readonly payconiq: "payconiq";
    readonly payline: "payline";
    readonly paypal: "paypal";
    readonly payzen: "payzen";
    readonly purse: "purse";
    readonly riverty: "riverty";
    readonly scalapay: "scalapay";
    readonly sipsv2: "sipsv2";
    readonly slimpay: "slimpay";
    readonly sogecommerce: "sogecommerce";
    readonly sogenactif: "sogenactif";
    readonly stripe: "stripe";
    readonly systempay: "systempay";
};
declare const PurseHeadlessCheckoutEventBusCodesEnum: {
    readonly HEADLESS_CHECKOUT_TOKENS_ARE_DISABLED: "HEADLESS_CHECKOUT_TOKENS_ARE_DISABLED";
    readonly HEADLESS_CHECKOUT_READY: "HEADLESS_CHECKOUT_READY";
    readonly HEADLESS_CHECKOUT_EXPIRED_SESSION: "HEADLESS_CHECKOUT_EXPIRED_SESSION";
    readonly HEADLESS_CHECKOUT_PAYMENT_FULFILLED: "HEADLESS_CHECKOUT_PAYMENT_FULFILLED";
    readonly HEADLESS_CHECKOUT_OTHER_ERROR: "HEADLESS_CHECKOUT_OTHER_ERROR";
    readonly HEADLESS_CHECKOUT_PAYMENT_ERROR: "HEADLESS_CHECKOUT_PAYMENT_ERROR";
};
declare const PurseHeadlessSecondariesErrorCodes: {
    readonly SECONDARIES_REQUIRED_CVV: "SECONDARIES_REQUIRED_CVV";
    readonly SECONDARIES_WRONG_PAN_FORMAT: "SECONDARIES_WRONG_PAN_FORMAT";
    readonly SECONDARIES_WRONG_CVV_FORMAT: "SECONDARIES_WRONG_CVV_FORMAT";
};
declare const ServerDatetime: ZodObject<{
    utc: ZodString;
    iso: ZodString;
}, "strip", ZodTypeAny, {
    utc: string;
    iso: string;
}, {
    utc: string;
    iso: string;
}>;
declare const SimulationCandidate: ZodObject<{
    plugin_result: ZodOptional<ZodNullable<ZodObject<{
        final_instalment_amount: ZodNumber;
        effective_annual_percentage_rate: ZodOptional<ZodNumber>;
        initial_instalment_amount: ZodNumber;
        instalment_amount: ZodNumber;
        instalment_number: ZodNumber;
        legal_text: ZodOptional<ZodString>;
        preferred: ZodBoolean;
        total_cost: ZodNumber;
    }, "strip", ZodTypeAny, {
        final_instalment_amount: number;
        initial_instalment_amount: number;
        instalment_amount: number;
        instalment_number: number;
        preferred: boolean;
        total_cost: number;
        effective_annual_percentage_rate?: number | undefined;
        legal_text?: string | undefined;
    }, {
        final_instalment_amount: number;
        initial_instalment_amount: number;
        instalment_amount: number;
        instalment_number: number;
        preferred: boolean;
        total_cost: number;
        effective_annual_percentage_rate?: number | undefined;
        legal_text?: string | undefined;
    }>>>;
}, "strip", ZodTypeAny, {
    plugin_result?: {
        final_instalment_amount: number;
        initial_instalment_amount: number;
        instalment_amount: number;
        instalment_number: number;
        preferred: boolean;
        total_cost: number;
        effective_annual_percentage_rate?: number | undefined;
        legal_text?: string | undefined;
    } | null | undefined;
}, {
    plugin_result?: {
        final_instalment_amount: number;
        initial_instalment_amount: number;
        instalment_amount: number;
        instalment_number: number;
        preferred: boolean;
        total_cost: number;
        effective_annual_percentage_rate?: number | undefined;
        legal_text?: string | undefined;
    } | null | undefined;
}>;
declare const SimulationCandidatePayload: ZodAny;
declare const THEME_SCOPES: readonly [
    "global",
    "input",
    "label",
    "helperText",
    "tooltip"
];
declare const THEME_SCOPES_CSS_KEYS: {
    readonly global: readonly [
        "color",
        "fontSize",
        "fontFamily",
        "fontWeight",
        "gap"
    ];
    readonly input: readonly [
        "color",
        "fontSize",
        "fontFamily",
        "borderRadius",
        "backgroundColor",
        "borderColor",
        "borderStyle",
        "borderWidth",
        "fontWeight",
        "fontStyle",
        "padding",
        "boxShadow",
        "outlineColor",
        "outlineStyle",
        "outlineWidth"
    ];
    readonly helperText: readonly [
        "color",
        "fontSize",
        "fontFamily",
        "fontWeight",
        "margin"
    ];
    readonly tooltip: readonly [
        "color",
        "fontSize",
        "fontFamily",
        "fontWeight",
        "borderRadius",
        "backgroundColor",
        "padding",
        "boxShadow"
    ];
    readonly label: readonly [
        "color",
        "fontSize",
        "fontFamily",
        "fontWeight",
        "margin"
    ];
};
declare const THEME_SCOPES_VARIANTS: {
    readonly global: readonly [
        ":valid",
        ":invalid"
    ];
    readonly input: readonly [
        ":hover",
        ":valid",
        ":focus",
        ":invalid",
        "::placeholder",
        "::placeholder:disabled",
        ":-webkit-autofill"
    ];
    readonly helperText: readonly [
        ":disabled",
        ":valid",
        ":invalid"
    ];
    readonly tooltip: readonly [
        ":focus",
        ":invalid"
    ];
    readonly label: readonly [
        ":valid",
        ":invalid"
    ];
};
declare const ValidationData: ZodObject<{
    errors: ZodOptional<ZodAny>;
    results: ZodArray<ZodObject<{
        id: ZodString;
        date: ZodString;
        method: ZodString;
        partner: ZodString;
        session_id: ZodString;
        transaction_id: ZodString;
        plugin_result: ZodAny;
        status: ZodObject<{
            action: ZodNativeEnum<typeof TransactionAction>;
            state: ZodNativeEnum<typeof StatusState>;
            description: ZodOptional<ZodString>;
            code: ZodNativeEnum<typeof StatusCode>;
        }, "strip", ZodTypeAny, {
            action: TransactionAction;
            code: StatusCode;
            state: StatusState;
            description?: string | undefined;
        }, {
            action: TransactionAction;
            code: StatusCode;
            state: StatusState;
            description?: string | undefined;
        }>;
    }, "strip", ZodTypeAny, {
        status: {
            action: TransactionAction;
            code: StatusCode;
            state: StatusState;
            description?: string | undefined;
        };
        date: string;
        method: string;
        partner: string;
        id: string;
        session_id: string;
        transaction_id: string;
        plugin_result?: any;
    }, {
        status: {
            action: TransactionAction;
            code: StatusCode;
            state: StatusState;
            description?: string | undefined;
        };
        date: string;
        method: string;
        partner: string;
        id: string;
        session_id: string;
        transaction_id: string;
        plugin_result?: any;
    }>, "many">;
    redirection: ZodObject<{
        should_submit_widget: ZodOptional<ZodBoolean>;
        url: ZodOptional<ZodString>;
        form: ZodOptional<ZodString>;
        name: ZodOptional<ZodString>;
    }, "strip", ZodTypeAny, {
        should_submit_widget?: boolean | undefined;
        url?: string | undefined;
        form?: string | undefined;
        name?: string | undefined;
    }, {
        should_submit_widget?: boolean | undefined;
        url?: string | undefined;
        form?: string | undefined;
        name?: string | undefined;
    }>;
    global_status: ZodNativeEnum<typeof StatusState>;
}, "strip", ZodTypeAny, {
    results: {
        status: {
            action: TransactionAction;
            code: StatusCode;
            state: StatusState;
            description?: string | undefined;
        };
        date: string;
        method: string;
        partner: string;
        id: string;
        session_id: string;
        transaction_id: string;
        plugin_result?: any;
    }[];
    redirection: {
        should_submit_widget?: boolean | undefined;
        url?: string | undefined;
        form?: string | undefined;
        name?: string | undefined;
    };
    global_status: StatusState;
    errors?: any;
}, {
    results: {
        status: {
            action: TransactionAction;
            code: StatusCode;
            state: StatusState;
            description?: string | undefined;
        };
        date: string;
        method: string;
        partner: string;
        id: string;
        session_id: string;
        transaction_id: string;
        plugin_result?: any;
    }[];
    redirection: {
        should_submit_widget?: boolean | undefined;
        url?: string | undefined;
        form?: string | undefined;
        name?: string | undefined;
    };
    global_status: StatusState;
    errors?: any;
}>;
declare const ValidationPayload: ZodArray<ZodObject<{
    method: ZodString;
    partner: ZodString;
    amount: ZodNumber;
    paymentData: ZodAny;
    partnerData: ZodAny;
    order: ZodAny;
    paymentPreferences: ZodAny;
    step_id: ZodOptional<ZodNumber>;
}, "strip", ZodTypeAny, {
    method: string;
    partner: string;
    amount: number;
    paymentData?: any;
    partnerData?: any;
    order?: any;
    paymentPreferences?: any;
    step_id?: number | undefined;
}, {
    method: string;
    partner: string;
    amount: number;
    paymentData?: any;
    partnerData?: any;
    order?: any;
    paymentPreferences?: any;
    step_id?: number | undefined;
}>, "many">;
declare const ZodIssueCode: {
    invalid_type: "invalid_type";
    invalid_literal: "invalid_literal";
    custom: "custom";
    invalid_union: "invalid_union";
    invalid_union_discriminator: "invalid_union_discriminator";
    invalid_enum_value: "invalid_enum_value";
    unrecognized_keys: "unrecognized_keys";
    invalid_arguments: "invalid_arguments";
    invalid_return_type: "invalid_return_type";
    invalid_date: "invalid_date";
    invalid_string: "invalid_string";
    too_small: "too_small";
    too_big: "too_big";
    invalid_intersection_types: "invalid_intersection_types";
    not_multiple_of: "not_multiple_of";
    not_finite: "not_finite";
};
declare const ZodParsedType: {
    string: "string";
    nan: "nan";
    number: "number";
    integer: "integer";
    float: "float";
    boolean: "boolean";
    date: "date";
    bigint: "bigint";
    symbol: "symbol";
    function: "function";
    undefined: "undefined";
    null: "null";
    array: "array";
    object: "object";
    unknown: "unknown";
    promise: "promise";
    void: "void";
    never: "never";
    map: "map";
    set: "set";
};
declare enum EventType {
    INFO = "INFO",
    ERROR = "ERROR",
    SUCCESS = "SUCCESS",
    WARNING = "WARNING",
    PERFORMANCE = "PERFORMANCE",
    UI = "UI",
    NETWORK = "NETWORK"
}
declare enum PaymentMethodSuspensions {
    NONE = "NONE",
    AMOUNT_OUT_OF_RANGE_MIN = "AMOUNT_OUT_OF_RANGE_MIN",
    AMOUNT_OUT_OF_RANGE_MAX = "AMOUNT_OUT_OF_RANGE_MAX",
    EXTERNAL_BREAK = "EXTERNAL_BREAK",
    PER_SESSION_LIMIT = "PER_SESSION_LIMIT"
}
declare enum StatusCode {
    SUCCEEDED = "SUCCEEDED",
    FAILED = "FAILED",
    CARD_EXPIRED = "CARD_EXPIRED",
    UNKNOWN = "UNKNOWN",
    FORCED = "FORCED",
    AMOUNT_EXCEEDED = "AMOUNT_EXCEEDED",
    BLOCKED_BY_CUSTOMER = "BLOCKED_BY_CUSTOMER",
    BLOCKED_CARD = "BLOCKED_CARD",
    DUPLICATED_TRANSACTION = "DUPLICATED_TRANSACTION",
    EXPIRED_AUTHORIZATION = "EXPIRED_AUTHORIZATION",
    INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS",
    REFUND_REQUESTED_TOO_LATE = "REFUND_REQUESTED_TOO_LATE",
    REJECTED_BANK = "REJECTED_BANK",
    REJECTED_BY_RISK_CHECKS = "REJECTED_BY_RISK_CHECKS",
    TECHNICAL_ISSUE_TO_CONTACT_PARTNER = "TECHNICAL_ISSUE_TO_CONTACT_PARTNER",
    TRANSACTION_NOT_SUPPORTED_BY_CARD = "TRANSACTION_NOT_SUPPORTED_BY_CARD",
    TRANSACTION_NOT_SUPPORTED_BY_MERCHANT_ACCOUNT = "TRANSACTION_NOT_SUPPORTED_BY_MERCHANT_ACCOUNT",
    UNKNOWN_CARD = "UNKNOWN_CARD",
    WAITING_PARTNER_RESPONSE = "WAITING_PARTNER_RESPONSE",
    WAITING_ONEPAY_ACTION = "WAITING_ONEPAY_ACTION",
    CARD_ALREADY_ACTIVE = "CARD_ALREADY_ACTIVE",
    TECHNICAL_ISSUE_DURING_AUTHENTICATION_CHECK = "TECHNICAL_ISSUE_DURING_AUTHENTICATION_CHECK",
    WRONG_CARD_DATA = "WRONG_CARD_DATA",
    BAD_REQUEST = "BAD_REQUEST",
    CARD_IS_NOT_ACTIVE = "CARD_IS_NOT_ACTIVE",
    ABORTED_BY_CUSTOMER = "ABORTED_BY_CUSTOMER",
    UNCERTAIN = "UNCERTAIN"
}
declare enum StatusState {
    SUCCESS = "SUCCESS",
    ERROR = "ERROR",
    UNCERTAIN = "UNCERTAIN",
    FAILED = "FAILED",
    WAITING = "WAITING"
}
declare enum TransactionAction {
    INIT = "INIT",
    APPLY = "APPLY",
    VOID = "VOID",
    CAPTURE = "CAPTURE",
    REFUND = "REFUND",
    AUTHORIZE = "AUTHORIZE",
    INIT_THREE_DS = "INIT_THREE_DS"
}
declare enum ZodFirstPartyTypeKind {
    ZodString = "ZodString",
    ZodNumber = "ZodNumber",
    ZodNaN = "ZodNaN",
    ZodBigInt = "ZodBigInt",
    ZodBoolean = "ZodBoolean",
    ZodDate = "ZodDate",
    ZodSymbol = "ZodSymbol",
    ZodUndefined = "ZodUndefined",
    ZodNull = "ZodNull",
    ZodAny = "ZodAny",
    ZodUnknown = "ZodUnknown",
    ZodNever = "ZodNever",
    ZodVoid = "ZodVoid",
    ZodArray = "ZodArray",
    ZodObject = "ZodObject",
    ZodUnion = "ZodUnion",
    ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    ZodIntersection = "ZodIntersection",
    ZodTuple = "ZodTuple",
    ZodRecord = "ZodRecord",
    ZodMap = "ZodMap",
    ZodSet = "ZodSet",
    ZodFunction = "ZodFunction",
    ZodLazy = "ZodLazy",
    ZodLiteral = "ZodLiteral",
    ZodEnum = "ZodEnum",
    ZodEffects = "ZodEffects",
    ZodNativeEnum = "ZodNativeEnum",
    ZodOptional = "ZodOptional",
    ZodNullable = "ZodNullable",
    ZodDefault = "ZodDefault",
    ZodCatch = "ZodCatch",
    ZodPromise = "ZodPromise",
    ZodBranded = "ZodBranded",
    ZodPipeline = "ZodPipeline",
    ZodReadonly = "ZodReadonly"
}
declare function createZodEnum<U extends string, T extends Readonly<[
    U,
    ...U[]
]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
declare function createZodEnum<U extends string, T extends [
    U,
    ...U[]
]>(values: T, params?: RawCreateParams): ZodEnum<T>;
/**
 * Some partners displays a complete form and let you configure the text through a JS configuration. We've mapped those
 * texts and let you override all off them form this single object. During a session, while displaying a form some of
 * the variables might not be used, it depends on the context.
 */
declare interface HostedFormUIOptions {
    panPlaceholder?: string;
    panInputLabel?: string;
    panRequiredError?: string;
    panFormatError?: string;
    panCannotBeEmptyError?: string;
    panTooltipText?: string;
    birthdatePlaceholder?: string;
    birthdateInputLabel?: string;
    birthdateRequiredError?: string;
    birthdateFormatError?: string;
    birthdateCannotBeEmptyError?: string;
    birthdateOutOfRangeError?: string;
    cvvPlaceholder?: string;
    cvvInputLabel?: string;
    /**
     * placeholder variant for cvv of length 4 (e.g. amex)
     */
    cvv4Placeholder?: string;
    /**
     * label variant for cvv of length 4 (e.g. amex)
     */
    cvv4InputLabel?: string;
    cvvRequiredError?: string;
    cvvFormatError?: string;
    cvvCannotBeEmptyError?: string;
    cvvTooltipText?: string;
    expirationPlaceholder?: string;
    expirationInputLabel?: string;
    expirationRequiredError?: string;
    expirationFormatError?: string;
    expirationCannotBeEmptyError?: string;
    expirationOutOfRangeError?: string;
    expirationTooltipText?: string;
    holderPlaceholder?: string;
    holderInputLabel?: string;
    holderRequiredError?: string;
    holderFormatError?: string;
    holderCannotBeEmptyError?: string;
    /**
     * implicit - Select in pan input with logo
     * explicit - Conventional select on top of the form
     * hidden   - Hide the brand selector
     */
    brandSelectionMode?: "implicit" | "explicit" | "hidden";
    explicitBrandText?: string;
    brandLabels?: {
        [key in CardScheme]?: string;
    };
}
/**
 * Apple, Google and PayPal buttons are treated differently and all the config is exposed through this object.
 */
declare interface XPayButtonUIOptions {
    apple?: {
        type?: "plain" | "buy" | "donate" | "check-out" | "book" | "subscribe" | "add-money" | "contribute" | "order" | "reload" | "rent" | "support" | "tip" | "top-up";
        buttonstyle?: "black" | "white" | "white-outline";
        width?: string;
        height?: string;
        borderRadius?: string;
        padding?: string;
        locale?: `${string}-${Uppercase<string>}` | `${string}`;
    };
    google?: GooglePayButtonOptions;
    paypal?: {
        layout?: "vertical" | "horizontal";
        color?: "silver" | "white" | "black" | "gold" | "blue";
        shape?: "rect" | "pill";
        height?: number;
        label?: "paypal" | "checkout" | "buynow" | "pay" | "installment";
    };
}
declare namespace StandardSchemaV1 {
    /**
     * The Standard Schema properties interface.
     */
    export interface Props<Input = unknown, Output = Input> {
        /**
         * The version number of the standard.
         */
        readonly version: 1;
        /**
         * The vendor name of the schema library.
         */
        readonly vendor: string;
        /**
         * Validates unknown input values.
         */
        readonly validate: (value: unknown) => Result<Output> | Promise<Result<Output>>;
        /**
         * Inferred types associated with the schema.
         */
        readonly types?: Types<Input, Output> | undefined;
    }
    /**
     * The result interface of the validate function.
     */
    export type Result<Output> = SuccessResult<Output> | FailureResult;
    /**
     * The result interface if validation succeeds.
     */
    export interface SuccessResult<Output> {
        /**
         * The typed output value.
         */
        readonly value: Output;
        /**
         * The non-existent issues.
         */
        readonly issues?: undefined;
    }
    /**
     * The result interface if validation fails.
     */
    export interface FailureResult {
        /**
         * The issues of failed validation.
         */
        readonly issues: ReadonlyArray<Issue>;
    }
    /**
     * The issue interface of the failure output.
     */
    export interface Issue {
        /**
         * The error message of the issue.
         */
        readonly message: string;
        /**
         * The path of the issue, if any.
         */
        readonly path?: ReadonlyArray<PropertyKey | PathSegment> | undefined;
    }
    /**
     * The path segment interface of the issue.
     */
    export interface PathSegment {
        /**
         * The key representing a path segment.
         */
        readonly key: PropertyKey;
    }
    /**
     * The Standard Schema types interface.
     */
    export interface Types<Input = unknown, Output = Input> {
        /**
         * The input type of the schema.
         */
        readonly input: Input;
        /**
         * The output type of the schema.
         */
        readonly output: Output;
    }
    /**
     * Infers the input type of a Standard Schema.
     */
    export type InferInput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["input"];
    /**
     * Infers the output type of a Standard Schema.
     */
    export type InferOutput<Schema extends StandardSchemaV1> = NonNullable<Schema["~standard"]["types"]>["output"];
    export {};
}
declare namespace enumUtil {
    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;
    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;
    type UnionToTuple<T, Tuple extends unknown[] = [
    ]> = [
        T
    ] extends [
        never
    ] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [
        GetUnionLast<T>,
        ...Tuple
    ]>;
    type CastToStringTuple<T> = T extends [
        string,
        ...string[]
    ] ? T : never;
    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;
    export {};
}
declare namespace errorUtil {
    type ErrMessage = string | {
        message?: string | undefined;
    };
    const errToObj: (message?: ErrMessage) => {
        message?: string | undefined;
    };
    const toString: (message?: ErrMessage) => string | undefined;
}
declare namespace objectUtil {
    export type MergeShapes<U, V> = keyof U & keyof V extends never ? U & V : {
        [k in Exclude<keyof U, keyof V>]: U[k];
    } & V;
    type optionalKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? k : never;
    }[keyof T];
    type requiredKeys<T extends object> = {
        [k in keyof T]: undefined extends T[k] ? never : k;
    }[keyof T];
    export type addQuestionMarks<T extends object, _O = any> = {
        [K in requiredKeys<T>]: T[K];
    } & {
        [K in optionalKeys<T>]?: T[K];
    } & {
        [k in keyof T]?: unknown;
    };
    export type identity<T> = T;
    export type flatten<T> = identity<{
        [k in keyof T]: T[k];
    }>;
    export type noNeverKeys<T> = {
        [k in keyof T]: [
            T[k]
        ] extends [
            never
        ] ? never : k;
    }[keyof T];
    export type noNever<T> = identity<{
        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;
    }>;
    export const mergeShapes: <U, T>(first: U, second: T) => T & U;
    export type extendShape<A extends object, B extends object> = keyof A & keyof B extends never ? A & B : {
        [K in keyof A as K extends keyof B ? never : K]: A[K];
    } & {
        [K in keyof B]: B[K];
    };
    export {};
}
declare namespace partialUtil {
    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape> ? ZodObject<{
        [k in keyof T["shape"]]: ZodOptional<DeepPartial<T["shape"][k]>>;
    }, T["_def"]["unknownKeys"], T["_def"]["catchall"]> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {
        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;
    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;
}
declare namespace util {
    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;
    export type isAny<T> = 0 extends 1 & T ? true : false;
    export const assertEqual: <A, B>(_: AssertEqual<A, B>) => void;
    export function assertIs<T>(_arg: T): void;
    export function assertNever(_x: never): never;
    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;
    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
    export type Exactly<T, X> = T & Record<Exclude<keyof X, keyof T>, never>;
    export type InexactPartial<T> = {
        [k in keyof T]?: T[k] | undefined;
    };
    export const arrayToEnum: <T extends string, U extends [
        T,
        ...T[]
    ]>(items: U) => {
        [k in U[number]]: k;
    };
    export const getValidEnumValues: (obj: any) => any[];
    export const objectValues: (obj: any) => any[];
    export const objectKeys: ObjectConstructor["keys"];
    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;
    export type identity<T> = objectUtil.identity<T>;
    export type flatten<T> = objectUtil.flatten<T>;
    export type noUndefined<T> = T extends undefined ? never : T;
    export const isInteger: NumberConstructor["isInteger"];
    export function joinValues<T extends any[]>(array: T, separator?: string): string;
    export const jsonStringifyReplacer: (_: string, value: any) => any;
    export {};
}
/**
 * Options let you override theme configuration and translations on our UIs.
 */
declare type Options$1 = {
    /**
     * Labels that can be found in a form
     * {@link HostedFormUIOptions}
     */
    [IntegrationTypes.hostedForm]?: HostedFormUIOptions;
    /**
     * Transparent config toward XPay partners (e.g. GooglePay ApplePay ...)
     * {@link XPayButtonUIOptions}
     */
    [IntegrationTypes.xPayButton]?: XPayButtonUIOptions;
    /**
     * Redirection config, used to override the title of the redirection
     * {@link RedirectionUIOptions}
     */
    [IntegrationTypes.redirection]?: RedirectionUIOptions;
    /**
     * This section holds the style configuration. Matters like, font, colors, spacing can be override using this config.
     * {@link PartnerUIOptionsTheme}
     */
    theme?: PartnerUIOptionsTheme;
    /**
     * Locale code is a combination of ISO 639-1 language code and ISO 3166-1 country code. For example, fr_FR is a locale code for French language in France.
     */
    locale?: `${string}-${Uppercase<string>}` | `${string}`;
};
declare type PartnerUIOptionsTheme = DeepPartial<PartnerUITheme>;
/**
 * A theme is carrying all the style variables use across our UIs.
 * global can be seen as a default values store on which the other scopes will rely on to fall back a value.
 */
declare type PartnerUITheme = {
    global: ThemeScope<"global"> & {
        /**
         * This is passed down to eligible partners to set the font url.
         * fontSrc is not a valid css style declaration key
         */
        fontSrc?: string;
    };
    input: ThemeScope<"input">;
    label: ThemeScope<"label">;
    helperText: ThemeScope<"helperText">;
    tooltip: ThemeScope<"tooltip">;
};
export declare class PurseHeadlessCheckout {
    /**
     * Checkout manager. Not to be used directly.
     * @protected
     */
    protected _checkout: Checkout;
    /**
     * Wallet manager. Not to be used directly.
     * @protected
     */
    protected _wallet: Wallet;
    protected _eventBus: PurseHeadlessCheckoutEventBus;
    private readonly _paymentElementFactory;
    private readonly _paymentTokenFactory;
    private readonly _hooks?;
    private readonly _allTokens;
    /**
     * List of available payment methods for the checkout.
     * This property is a Writable object containing an array of PurseCheckoutPaymentMethod.
     * Each payment-element in the array represents a payment method with its associated properties.
     * @type {Readable<Array<PurseHeadlessCheckoutPaymentMethod>>}
     * @example
     * ```ts
     * headlessCheckout.paymentMethods.subscribe((methods: PurseCheckoutPaymentMethod[]) => {
     *    console.log('The payment methods changed', methods);
     *    // Perhaps update the UI with the new methods
     * });
     * ```
     */
    readonly paymentMethods: Writable<PurseHeadlessCheckoutPaymentMethod[]>;
    /**
     * List of available payment tokens for the checkout.
     * This property is a Writable object containing an array of PurseCheckoutPaymentToken.
     * Each payment-element in the array represents a payment token with its associated properties.
     * @type {Readable<Array<PurseCheckoutPaymentToken>>}
     * @example
     * ```ts
     * headlessCheckout.paymentTokens.subscribe((tokens: PurseCheckoutPaymentToken[]) => {
     *   console.log('The payment tokens changed', tokens);
     *   // Perhaps update the UI with the new tokens
     * });
     * ```
     */
    readonly paymentTokens: Writable<PurseHeadlessCheckoutPaymentToken[]>;
    /**
     * This property indicates if the payment can be submitted.
     * @example
     * ```ts
     * headlessCheckout.isPaymentFulfilled.subscribe((isFulfilled: boolean) => {
     *    if(isFulfilled) {
     *      enablePayButton();
     *    }else{
     *      disablePayButton();
     *    }
     * });
     * ```
     */
    readonly isPaymentFulfilled: Readable<boolean>;
    /**
     * The remaining amount to pay represents the amount that is left to pay after the secondary payment method(s) has been used.
     * @example
     * ```ts
     * headlessCheckout.remainingAmountToPay.subscribe((amount: number) => {
     *    console.log('Perhaps update the text in your pay button', amount);
     * });
     * ```
     * */
    remainingAmountToPay: Readable<number>;
    /**
     * Splits represent the repartition between the primary payment method and the secondary payment methods.
     * @link PurseHeadlessCheckoutPaymentSplit
     * @example
     * ```ts
     * headlessCheckout.amountSplit.subscribe((splits: PurseHeadlessCheckoutPaymentSplit[]) => {
     *    console.log('The payment composition changed', splits);
     * });
     * ```
     * */
    amountSplit: Readable<PurseHeadlessCheckoutPaymentSplit[]>;
    private constructor();
    /**
     * @internal
     * Creates an instance of HeadlessCheckout.
     * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params} checkoutParams - The checkoutParams data for initializing the checkout.
     * @param {PurseHeadlessCheckoutHooks} hooks - Optional hooks into checkout lifecycle
     */
    static init(checkoutParams: PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params, hooks?: PurseHeadlessCheckoutHooks, apiPaths?: APIPaths): Promise<PurseHeadlessCheckout>;
    /**
     * Cleans up resources and removes event listeners.
     * @example
     * ```ts
     * headlessCheckout.teardown();
     * ```
     */
    teardown(): void;
    /**
     * Sets the wallet session. The wallet session is used to retrieve and manage the user's stored card tokens.
     * @param {WalletSessionModel} walletSession
     * @throws {PurseHeadlessCheckoutError} If setting the wallet session fails
     * @example
     * ```ts
     * headlessCheckout.setWalletSession(walletSession);
     * ```
     */
    setWalletSession(walletSession: WalletSessionModel): Promise<Wallet<WalletActions>> | undefined;
    /**
     * Remove all tokens from the provided wallet session
     * @throws {PurseHeadlessCheckoutWalletSessionMissingError} If the wallet session is missing
     * @throws {PurseHeadlessCheckoutError} If deleting the tokens fails
     * @example
     * ```ts
     * headlessCheckout.deleteAllTokens();
     * ```
     */
    deleteAllTokens(): Promise<void>;
    /**
     * Clears the primary split from the amount share.
     * Nothing happens if the primary split is already cleared.
     * @example
     * ```ts
     * headlessCheckout.clearPrimarySplit();
     * ```
     */
    clearPrimarySplit(): void;
    protected _setSession(session: PurseHeadlessCheckoutV1Params["paymentSession"]): Promise<void>;
    /**
     * Updates the session with the provided session data.
     * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params['paymentSession']} widgetData - The session data. Can be either an encoded string (V2) or a payment session object (V1).
     * @example
     * ```ts
     * headlessCheckout.setSession(paymentSession);
     * ```
     */
    setSession(widgetData: PurseHeadlessCheckoutV2Params): Promise<void>;
    setSession(widgetData: PurseHeadlessCheckoutV1Params["paymentSession"]): Promise<void>;
    private _submitPayment;
    /**
     * Submits the current payment configuration for processing.
     * This will validate and process all payment methods in the current split configuration.
     *
     * @throws {HeadlessCheckoutError} If:
     *  - No payment methods are configured
     *  - Payment validation fails
     *  - Payment processing fails
     *  - The total amount does not match the session amount
     *
     * @example
     * ```typescript
     * try {
     *   // Configure payment methods and amounts
     *   await primaryMethod.setAsPrimarySource();
     *   await secondaryToken.take(50.00);
     *
     *   // Submit the payment
     *   await checkout.submitPayment();
     *   console.log('Payment successful!');
     * } catch (error) {
     *   console.error('Payment failed:', error);
     * }
     * ```
     */
    submitPayment(): Promise<void>;
    /**
     * @internal
     * Checks if a payment token is an integrated token.
     * Integrated tokens are tokens that have been processed through a partner's system
     * and contain a uniqueness token for tracking.
     *
     * @param token - The payment token to check
     * @returns true if the token is integrated (has a uniqueness token), false otherwise
     */
    private _isIntegrated;
}
/**
 * This error is thrown when the payment element is not fulfilled
 * @group Errors
 */
export declare class PurseHeadlessCheckoutElementNotFulfilledError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_ELEMENT_NOT_FULFILLED> {
    constructor();
}
/**
 * This error is thrown when the payment element UI validation failed
 * @group Errors
 */
export declare class PurseHeadlessCheckoutElementUIValidationFailedError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_UI_VALIDATION_FAILED_ERROR> {
    constructor();
}
/**
 * Generic class for headless checkout
 * @group Errors
 * @param T - Error code
 */
export declare class PurseHeadlessCheckoutError<T extends PurseHeadlessCheckoutErrorCodesValues | void = void> extends Error {
    code?: PurseHeadlessCheckoutErrorCodesValues;
    name: string;
    origin?: Error;
    constructor(message: string, code?: T | null, origin?: Error);
}
/**
 * This error is thrown when the session is expired
 * @group Errors
 */
export declare class PurseHeadlessCheckoutExpiredSessionError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_EXPIRED_SESSION> {
    constructor();
}
/**
 * This error is thrown when the session is missing
 * @group Errors
 */
export declare class PurseHeadlessCheckoutSessionMissingError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_MISSING_SESSION> {
    constructor();
}
/**
 * This error is thrown when the token is missing
 * @group Errors
 */
export declare class PurseHeadlessCheckoutTokenMissingError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_MISSING_TOKEN> {
    constructor();
}
/**
 * This error is thrown when the token name already exists
 * @group Errors
 */
export declare class PurseHeadlessCheckoutTokenNameExistsError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_TOKEN_NAME_EXISTS> {
    constructor();
}
/**
 * This error is thrown when the token registration is not allowed
 * @group Errors
 */
export declare class PurseHeadlessCheckoutTokenNotRegisterableError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_TOKEN_NOT_REGISTERABLE> {
    constructor();
}
/**
 * This error is thrown when the token is not registered
 * @group Errors
 */
export declare class PurseHeadlessCheckoutTokenNotRegisteredError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_TOKEN_NOT_REGISTERED> {
    constructor();
}
/**
 * This error is thrown when the max usage limit is reached for a method
 * @group Errors
 */
export declare class PurseHeadlessCheckoutUsageLimitError extends PurseHeadlessCheckoutError {
    constructor(partner: string, method: string);
}
/**
 * This error is thrown when the wallet session is missing
 * @group Errors
 */
export declare class PurseHeadlessCheckoutWalletSessionMissingError extends PurseHeadlessCheckoutError<typeof PurseHeadlessCheckoutErrorCodes.HEADLESS_CHECKOUT_MISSING_WALLET_SESSION> {
    constructor();
}
/**
 * Available codes to check for headless checkout errors
 *
 * @group Errors
 */
export declare const PurseHeadlessCheckoutErrorCodes: {
    readonly HEADLESS_CHECKOUT_EXPIRED_SESSION: "HEADLESS_CHECKOUT_EXPIRED_SESSION";
    readonly HEADLESS_CHECKOUT_MISSING_SESSION: "HEADLESS_CHECKOUT_MISSING_SESSION";
    readonly HEADLESS_CHECKOUT_MISSING_WALLET_SESSION: "HEADLESS_CHECKOUT_MISSING_WALLET_SESSION";
    readonly HEADLESS_CHECKOUT_TOKEN_NOT_REGISTERABLE: "HEADLESS_CHECKOUT_TOKEN_NOT_REGISTERABLE";
    readonly HEADLESS_CHECKOUT_TOKEN_NOT_REGISTERED: "HEADLESS_CHECKOUT_TOKEN_NOT_REGISTERED";
    readonly HEADLESS_CHECKOUT_TOKEN_NAME_EXISTS: "HEADLESS_CHECKOUT_TOKEN_NAME_EXISTS";
    readonly HEADLESS_CHECKOUT_ELEMENT_NOT_FULFILLED: "HEADLESS_CHECKOUT_ELEMENT_NOT_FULFILLED";
    readonly HEADLESS_CHECKOUT_INVALID_LOAN_SIMULATION: "HEADLESS_CHECKOUT_INVALID_LOAN_SIMULATION";
    readonly HEADLESS_CHECKOUT_UI_VALIDATION_FAILED_ERROR: "HEADLESS_CHECKOUT_UI_VALIDATION_FAILED_ERROR";
    readonly HEADLESS_CHECKOUT_MISSING_TOKEN: "HEADLESS_CHECKOUT_MISSING_TOKEN";
};
/**
 * Creates and initializes a new headless checkout instance.
 * Use this function to start a new payment session with the Purse checkout system.
 * @param {PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params} sessionParams - The checkout session configuration.
 * @param hooks - Optional lifecycle hooks to customize checkout behavior
 *               See {@link PurseHeadlessCheckoutHooks} for available hooks
 * @returns A promise that resolves to a configured checkout instance
 */
export declare const createHeadlessCheckout: <T extends PurseHeadlessCheckoutV2Params | PurseHeadlessCheckoutV1Params, H extends PurseHeadlessCheckoutHooks>(sessionParams: T, hooks?: H, apiPaths?: APIPaths) => Promise<PurseHeadlessCheckout>;
export declare function buildSecondaryTemporaryTokensPayload(checkoutTokensList: Readable<Array<PaymentToken>>, splits: PurseHeadlessCheckoutPaymentSplit[]): ItemPayload[];
export declare interface CreditCardValidateUiResult {
    cardNumber: string | null;
    cvv: string | null;
    expiryDate: string | null;
    holderName: string | null;
}
export declare interface ItemPayload {
    method: Method;
    partner: Partner;
    amount: number;
    payment_data: any;
    partner_data: any;
    order?: any;
    payment_preferences: any;
    step_id?: number | null;
}
export declare interface RedirectionUIOptions {
    title?: string;
}
export declare type ButtonOptions = google.payments.api.ButtonOptions;
export declare type CardScheme = (typeof CardSchemes)[keyof typeof CardSchemes];
export declare type DeepPartial<T> = T extends any[] ? T : {
    [P in keyof T]?: DeepPartial<T[P]>;
};
export declare type EventCode = (typeof Events)[keyof typeof Events]["code"];
export declare type GooglePayButtonOptions = Partial<Pick<ButtonOptions, "buttonColor" | "buttonType" | "buttonLocale" | "buttonRadius" | "buttonSizeMode">>;
export declare type Method = (typeof Methods)[keyof typeof Methods];
export declare type Partner = (typeof Partners)[keyof typeof Partners];
export declare type ThemeScope<Scope extends ThemeScopeName> = {
    [cssKey in ThemeScopeCSSKeys<Scope>]?: CSSStyleDeclaration[cssKey];
} & {
    [variant in ThemeScopesVariants<Scope>]?: {
        [cssKey in ThemeScopeCSSKeys<Scope>]?: CSSStyleDeclaration[cssKey];
    };
};
export declare type ThemeScopeCSSKeyMap = {
    [K in ThemeScopeName]: (typeof THEME_SCOPES_CSS_KEYS)[K][number];
};
export declare type ThemeScopeCSSKeys<S extends ThemeScopeName> = ThemeScopeCSSKeyMap[S];
export declare type ThemeScopeName = (typeof THEME_SCOPES)[number];
export declare type ThemeScopesVariants<Scope extends ThemeScopeName> = ThemeScopesVariantsMap[Scope];
export declare type ThemeScopesVariantsMap = {
    [K in ThemeScopeName]: (typeof THEME_SCOPES_VARIANTS)[K][number];
};
export interface APIConstructor {
    environment: APIEnvironment;
    apiKey: string;
    entityId: string;
    beacon?: Beacon;
    root: string;
}
export interface Currency {
    add(number: Any): Currency;
    subtract(number: Any): Currency;
    multiply(number: Any): Currency;
    divide(number: Any): Currency;
    distribute(count: number): Array<Currency>;
    dollars(): number;
    cents(): number;
    format(opts?: Options | Format): string;
    toString(): string;
    toJSON(): number;
    readonly intValue: number;
    readonly value: number;
}
export interface GatewayAPI {
    getServerTime(): Promise<APIResponse<ServerDatetime>>;
    init(sessionId: string, payload: PartnerPayload): Promise<APIResponse<InitData>>;
    init3DS(sessionId: string, payload: PartnerPayload): Promise<APIResponse<InitData>>;
    validate(sessionId: string, validateData: ValidationPayload): Promise<APIResponse<ValidationData>>;
    getSimulationsCandidates(entityId: string, body: SimulationCandidatePayload): Promise<APIResponse<SimulationCandidate[]>>;
    getSimulation(entityId: string, partner: string, method: string, body: SimulationCandidatePayload): Promise<APIResponse<SimulationCandidate>>;
    getOwnerTokens(data: {
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
        vault: boolean;
    }): Promise<APIResponse<OwnerTokens>>;
    deleteOwnerToken(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
    }): Promise<APIResponse<void>>;
    deleteOwnerTokenName(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
    }): Promise<APIResponse<void>>;
    editTokenName(data: {
        id: string;
        ownerId: string;
        walletSessionId: string;
        merchantId: string;
        name: string;
    }): Promise<APIResponse<void>>;
    sendLogs(evts: Event$1[], extraData: {
        version?: string;
        paymentSessionId?: string;
        walletSessionId?: string;
        entityId?: string;
        env?: APIEnvironment;
    }): void;
}
export interface ItemActions {
    buildData: () => Record<string, any>;
}
export interface LoanProduct {
    amount: number;
    currency_code: string;
}
export interface LoanSimulation {
    /** first installment amount **/
    initialInstallmentAmount: number;
    /** last installment amount **/
    finalInstallmentAmount: number;
    /** Cost of recurrent installments **/
    installmentAmount: number;
    /** Cost of the loan (not including amount) **/
    totalCost: number;
    /** Number of installments **/
    installmentCount: number;
    /** Some loan simulation will provide a legal text to display next to the offer **/
    legalText?: string;
    /** Annual Percentage Rate Cost **/
    aprc?: number;
}
export interface Options {
    symbol?: string;
    separator?: string;
    decimal?: string;
    errorOnInvalid?: boolean;
    precision?: number;
    increment?: number;
    useVedic?: boolean;
    pattern?: string;
    negativePattern?: string;
    format?: Format;
    fromCents?: boolean;
}
export interface ParseContext {
    readonly common: {
        readonly issues: ZodIssue[];
        readonly contextualErrorMap?: ZodErrorMap | undefined;
        readonly async: boolean;
    };
    readonly path: ParsePath;
    readonly schemaErrorMap?: ZodErrorMap | undefined;
    readonly parent: ParseContext | null;
    readonly data: any;
    readonly parsedType: ZodParsedType;
}
export interface PaymentElementEventsCallback {
    /** Handler for fatal error events */
    fatalError: (payload: PaymentElementEventsPayload["fatalError"]) => void;
    /** Handler for form validation success events */
    formValid: (payload: PaymentElementEventsPayload["formValid"]) => void;
    /** Handler for validation request events */
    validationRequested: (payload: PaymentElementEventsPayload["validationRequested"]) => void;
}
export interface PaymentElementEventsPayload {
    fatalError: {
        code: string;
        reason: string;
        internalEventCode: EventCode;
    };
    formValid: {
        isValid: boolean;
    };
    validationRequested: ItemPayload;
}
export interface PaymentItemActionsBuilder<T = undefined> {
    buildForItem: (item: PaymentItem$1<any, any>) => T;
}
export interface PaymentItemInterface<Actions extends ItemActions = typeof NoopActions> {
    partner: string;
    method: string;
    id: string;
    isSecondary: boolean;
    partnerData: Writable<any>;
    paymentData: Writable<any>;
    paymentPreferences: Writable<any>;
    deactivated: Writable<boolean>;
    buildData(): PaymentItemData;
    deactivate(): void;
    get actions(): Actions | undefined;
    rewireMethodName(method: string | null): void;
}
/**
 * Base interface for all payment items in the Purse checkout system.
 * Provides common properties shared between payment methods and tokens.
 *
 * @remarks
 * This interface should not be used directly in your application code.
 * Instead, use {@link PurseHeadlessCheckoutMethod} or {@link PurseHeadlessCheckoutToken}.
 */
export interface PurseHeadlessCheckoutBase {
    /** Unique identifier of the payment method
     * @example 'hipay-bancontact'
     * @example 'illicado-giftcard'
     * @example 'aci-creditcard'
     *
     */
    id: string;
    /** Partner associated with the payment method
     * @example 'hipay'
     * @example 'payconiq'
     * @example 'paypal'
     */
    partner: string;
    /** Type of payment method, it can be a card, a wallet, a bank transfer, etc.
     * @example 'applepay'
     * @example 'googlepay'
     * @example 'creditcard'
     */
    method: string;
    type: "method" | "token";
    /** Indicates if the payment method is a secondary mean of payment */
    isSecondary: boolean;
}
export interface PurseHeadlessCheckoutEditable {
    /**
     * Delete the token from the user's wallet
     * @example
     * ```typescript
     * token.delete();
     * ```
     */
    delete(): Promise<void>;
    /**
     * Edit the token's name
     * @param payload
     * @throws HeadlessCheckoutTokenNotRegisterable if the token is not registerable
     * @throws HeadlessCheckoutTokenNotRegistered if the token is not registered
     * @throws HeadlessCheckoutTokenNameExists if the token name already exists
     * @example
     * ```typescript
     * token.edit({ name: 'New Name' });
     * ```
     */
    edit(payload: {
        name: string;
    }): Promise<void>;
}
export interface PurseHeadlessCheckoutEventBusEvent<T> extends Event$1<T> {
    code: PurseHeadlessCheckoutEventCodes;
    payload?: T;
}
export interface PurseHeadlessCheckoutHooks {
    /** Optional argument to pass a callback to invoke before performing the final redirection */
    onBeforeRedirect?: () => Promise<void>;
}
/**
 * Represents an available payment method in the Purse checkout system.
 * Payment methods can be primary (e.g., credit cards, digital wallets) or secondary (e.g., gift cards).
 */
export interface PurseHeadlessCheckoutMethod extends PurseHeadlessCheckoutBase {
    type: "method";
    /** Indicates if the payment method is disabled (Writable to allow dynamic updates) */
    disabled: Writable<boolean>;
    /** Position of the payment method in the list */
    position: number;
    /** Amount limit for the payment method (null if no limit) */
    limit: number | null;
}
/**
 * Interface for managing and interacting with a payment partner's UI component.
 * Provides methods to render, configure, and handle events from payment UIs like credit card forms or digital wallet buttons.
 *
 * @example
 * ```typescript
 * // Get a payment element from a payment method
 * const paymentElement = method.getPaymentElement();
 *
 * // Configure the UI See {@link Options}
 * paymentElement.setOptions({
 *   hostedForm: {
 *     panPlaceholder: 'Enter your card number',
 *     cvvPlaceholder: 'Enter your CVV'
 *     // Add more options here
 *   },
 *   theme:{
 *     global:{
 *        fontSize: "12px"
 *     }
 *   }
 * });
 *
 * // Render the UI
 * paymentElement.appendTo('#payment-form');
 *
 * // Listen for events
 * paymentElement.on('formValid', () => {
 *   console.log('Payment UI form is valid');
 * });
 * ```
 */
export interface PurseHeadlessCheckoutPaymentElement {
    /**
     * Configures the appearance and behavior of the payment UI.
     * Use this to customize the look and feel of the payment form to match your application's design.
     *
     * @param options - Configuration options for the payment UI
     *                 See {@link Options} for available customization options
     * @example
     * ```typescript
     * paymentElement.setOptions({
     *   hostedForm: {
     *     panPlaceholder: 'Enter your card number',
     *     cvvPlaceholder: 'Enter your CVV'
     *     // Add more options here
     *   }
     * });
     * ```
     */
    setOptions(options?: Options$1): void;
    /**
     * Renders the payment UI into the specified container element.
     * The container can be either a CSS selector string or a direct reference to an HTML element.
     *
     * @param container - CSS selector (e.g., '#payment-form') or HTML element to render the UI into
     * @throws {Error} If the container element cannot be found or is invalid
     * @example
     * ```typescript
     * // Using a CSS selector
     * paymentElement.appendTo('#payment-form');
     *
     * // Using an HTML element
     * const container = document.getElementById('payment-form');
     * paymentElement.appendTo(container);
     * ```
     */
    appendTo(container: string | Element): void;
    /**
     * Checks if the payment partner provides a visual UI component.
     * Use this to determine if you need to allocate space in your layout for the payment UI.
     * Some payment methods (like redirect-based flows) might not have a UI component.
     *
     * @returns true if the payment method has a UI component to display, false otherwise
     * @example
     * ```typescript
     * if (paymentElement.hasUI()) {
     *   // Add conditional styles or layout adjustments
     *   // based on the presence of a payment UI
     * }
     * ```
     */
    hasUI(): boolean;
    /**
     * Force the payment UI to validate the form fields.
     * For credit cards, this checks if all required fields are filled and valid.
     * For other payment methods, this verifies if the UI is in a valid state for submission.
     *
     * @returns A promise that resolves to:
     *          - boolean: true if validation passed, false if failed
     *          - CreditCardValidateUiResult: detailed validation results for credit card forms
     * @example
     * ```typescript
     * const isValid = await paymentElement.validateUi();
     * if (isValid) {
     *   // show success message
     *   console.log('Payment form is valid');
     * } else {
     *  // show error message
     *  console.error('Payment form is invalid');
     * }
     * ```
     */
    validateUi(): Promise<boolean | CreditCardValidateUiResult>;
    /**
     * Removes the payment UI from the DOM and cleans up any associated resources.
     * Call this when the payment UI is no longer needed or when switching payment methods.
     *
     * @example
     * ```typescript
     * // Clean up the payment UI when switching methods
     * paymentElement.remove();
     * ```
     */
    remove(): void;
    /**
     * Registers an event listener for payment UI events.
     * Listen for events like 'ready', 'change', 'blur', 'focus', etc.
     *
     * @param {PaymentElementEventName} eventName - Name of the event to listen for
     * @param callback - Function to be called when the event occurs
     * @example
     * ```typescript
     * // Listen for the UI ready event
     * paymentElement.on('formValid', () => {
     *   console.log('Payment UI form is valid');
     * });
     */
    on<K extends PaymentElementEventName>(eventName: K, callback: PaymentElementEventsCallback[K]): void;
}
/**
 * Represents a payment split configuration where multiple payment sources can be combined to fulfill the total payment amount.
 * The sum of all splits must equal the total payment amount.
 */
export interface PurseHeadlessCheckoutPaymentSplit {
    source: PurseHeadlessCheckoutPaymentItem;
    amount: number;
}
/**
 * Represents a primary payment method in the Purse checkout system.
 * Primary methods are the main payment options like credit cards, digital wallets, or bank transfers.
 *
 * @example
 * ```typescript
 * // Get payment element for a primary method
 * const primaryMethod: PurseHeadlessCheckoutPrimaryMethod = ...
 * const element = await primaryMethod.getPaymentElement({
 *   hostedForm: {
 *     panPlaceholder: 'Enter your card number',
 *     cvvPlaceholder: 'Enter your CVV'
 *     // Add more options here
 *   }
 * });
 *
 * // Mount the payment element to your UI
 * element.appendTo('#payment-container');
 * ```
 */
export interface PurseHeadlessCheckoutPrimaryMethod extends PurseHeadlessCheckoutMethod, PurseHeadlessCheckoutRegisterable {
    isSecondary: false;
    /** Whether the method can provide loan simulation or not*/
    simulable: boolean;
    /**
     * Creates and returns a payment element UI instance for this payment method.
     * The instance is created only on the first call and cached for subsequent calls.
     *
     * @param options - Optional UI customization settings for the payment element
     * @returns A payment element instance for this payment method
     * @throws {HeadlessCheckoutError} If the payment element creation fails
     * @example
     * ```typescript
     * const paymentElement = primaryMethod.getPaymentElement({
     *   hostedForm: {
     *     panPlaceholder: 'Enter your card number',
     *     cvvPlaceholder: 'Enter your CVV'
     *     // Add more options here
     *   }
     * })
     * await paymentElement.appendTo('#payment-container');
     * ```
     */
    getPaymentElement(options?: Options$1): PurseHeadlessCheckoutPaymentElement;
    /**
     * Changes the active primary payment source in the current payment split.
     * Use this when you have multiple primary payment elements mounted (e.g., Wallet AND installments).
     *
     * @throws {HeadlessCheckoutError} If the method cannot be set as primary source
     * @example
     * ```typescript
     * // Switch to this payment method as the primary source
     * await method.setAsPrimarySource();
     * ```
     */
    setAsPrimarySource(): void;
    /**
     * Some method are 'simulable' and can give a loan simulation if provided with a product description
     *
     * @throws {HeadlessCheckoutError} If the method can't provide a simulation
     * @example
     * ```typescript
     * await method.simulateLoan({ amount: 200, shipments: [], currency_code: 'EUR',...  });
     * ```
     */
    simulateLoan(product: LoanProduct): Promise<LoanSimulation>;
}
/**
 * Represents a primary token in the Purse checkout system.
 * Primary tokens are saved payment methods like stored credit cards or digital wallet accounts.
 */
export interface PurseHeadlessCheckoutPrimaryToken extends PurseHeadlessCheckoutToken {
    /** Indicates if the token is a secondary mean of payment */
    isSecondary: false;
    /**
     * Description holds all display values to describe the token in a UI. This is useful since the rendering of a token
     * is limited to the CVV.
     */
    description: {
        /**
         * Label is optional, the user have not necessarily given a label to the token when creating it.
         */
        label?: string;
        /**
         * Brand of the token
         */
        brand?: string;
        /**
         * Holder name of the token
         */
        holderName?: string;
        /**
         * Will contain displayable value of the PAN or the account email
         */
        masked_pan: string;
        /**
         * Date at which the token is excepted to expire
         */
        expiration_date: string;
    };
    /** Method to get the payment element. Creates the UI instance on first call.
     * If you need to render a partner's UI, you will need a PaymentElement
     * @param options {Options | undefined}
     * @return {PurseHeadlessCheckoutPaymentElement}
     * @example
     * ```typescript
     * const paymentElement = token.getPaymentElement();
     * // Mount the payment element to your UI
     * paymentElement.appendTo('#payment-container');
     * ```
     * */
    getPaymentElement(options?: Options$1): PurseHeadlessCheckoutPaymentElement;
    /** Use this method if you want to change which primary to use in the split.
     * This can be useful if you have moutned multiple primary payment elements (ie. Wallet AND installments for
     * instance).
     * @example
     * ```typescript
     * token.setAsPrimarySource();
     * ```
     */
    setAsPrimarySource(): void;
}
export interface PurseHeadlessCheckoutRegisterable {
    /**
     * Mark this mean of payment for registration upon validate.
     * @param value {boolean} true to register, false to unregister
     * @param params
     * @example
     * ```typescript
     * item.register(true);
     * ```
     */
    register(value?: boolean, params?: {
        name?: string;
    }): Promise<void>;
    /**
     * This property exposes the saveToken configuration of the method.
     * A mean of payment cannot be saved if the method is not registerable.
     */
    canBeRegistered: boolean;
    /**
     * This property exposes if the mean of payment is bound for registration upon validate.
     */
    registration: Readable<RegistrationState>;
}
/**
 * Represents a secondary token in the Purse checkout system.
 * Secondary tokens are saved alternative payment methods like gift cards that can be combined with primary payment methods.
 *
 * @example
 * ```typescript
 * // Use part of the gift card balance
 * await secondaryToken.take(50);
 *
 * // Remove it from the split if needed
 * await secondaryToken.removeFromSplit();
 * ```
 */
export interface PurseHeadlessCheckoutSecondaryToken extends PurseHeadlessCheckoutToken {
    isSecondary: true;
    limit?: number;
    expiration_date: string;
    /**
     * The amount available for use on the card.
     */
    balance: number;
    /**
     * the card pan
     */
    pan: string;
    /**
     * the card cvv
     */
    cvv?: string;
    /**
     * Applies a specified amount from this secondary token to the current payment session.
     * The amount will be deducted from the token's balance and added to the payment split.
     *
     * @param amount - Amount to use from this token's balance
     * @throws {HeadlessCheckoutError} If any of these conditions are not met:
     *  - Amount must be greater than 0
     *  - Amount must be less than the remaining session amount
     *  - Amount must be less than the token's available balance
     * @example
     * ```typescript
     * // Use 50 from a gift card balance
     * await token.take(50);
     * ```
     */
    take(amount: number): Promise<void>;
    /**
     * Removes this token from the current payment split configuration.
     * Any amount previously allocated from this token will be removed from the split.
     *
     * @throws {HeadlessCheckoutError} If the token cannot be removed from the split
     * @example
     * ```typescript
     * // Remove a gift card from the payment split
     * await token.removeFromSplit();
     * ```
     */
    removeFromSplit(): Promise<void>;
}
export interface PurseHeadlessCheckoutSecondaryTokenProvider {
    getSecondaryToken(pan: string, cvv?: string): Promise<PurseHeadlessCheckoutSecondaryToken>;
}
export interface PurseHeadlessCheckoutTemporarySecondaryToken extends PurseHeadlessCheckoutSecondaryToken, PurseHeadlessCheckoutRegisterable {
}
/**
 * Represents a saved payment token in the Purse checkout system.
 * Tokens are secure references to saved payment methods like stored credit cards or digital wallet accounts.
 * // Edit token name
 * await token.edit({ name: 'Personal Card' });
 *
 * // Delete token
 * await token.delete();
 * ```
 */
export interface PurseHeadlessCheckoutToken extends PurseHeadlessCheckoutBase, PurseHeadlessCheckoutEditable {
    name: string;
    type: "token";
    /**
     * True mean that the token can't be involved in the checkout.
     * Mainly set to true upon creation failure
     */
    disabled: Readable<boolean>;
}
/**
 * Interface representing a V1 session for the Headless Checkout.
 */
export interface PurseHeadlessCheckoutV1Params {
    /** API key for authentication */
    apiKey: string;
    /** Unique identifier for the merchant entity */
    entityId: string;
    /** Target environment for the checkout (e.g., 'sandbox', 'production') */
    environment: EnvironmentTarget;
    /** Payment session data containing transaction details */
    paymentSession: PurseHeadlessCheckoutV1SessionData;
}
export interface RedirectionHandler {
    submitRedirectionForm: (action: string, serializedFormData: string, method?: "GET" | "POST") => Promise<void> | void;
    submitStringRedirectionForm: (id: string, responseForm: any) => Promise<void> | void;
    redirectToUrl: (url: string) => Promise<void> | void;
}
export interface RefinementCtx {
    addIssue: (arg: IssueData) => void;
    path: (string | number)[];
}
/**
 * Secondaries are true Headless payment methods and are handled directly by the SDK for now.
 * They are not handled by the partner UI.
 */
export interface SecondarySpecificConfig {
    /**
     * Does this method require a CVV?
     */
    requiresCVV: (pan: string) => boolean;
    /**
     * Validates the pan of the card.
     */
    validatePan: (pan: string) => boolean;
    /**
     * Validates the pan of the card.
     */
    validateCVV?: (cvv: string) => boolean;
}
export interface Subscribable<T> {
    subscribe(run: StoreSubscriber<T>, invalidate?: StoreInvalidator<T>): StoreUnsubscriber;
}
export interface SvelteWritable<T> extends Subscribable<T> {
    /**
     * Set value and inform subscribers.
     * @param value to set
     */
    set(value: T): void;
    /**
     * Update value using callback and inform subscribers.
     * @param updater callback
     */
    update(updater: StoreUpdater<T>): void;
}
export interface WithGetter<T> {
    get value(): T;
    getValue(): T;
}
export interface ZodAnyDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodAny;
}
export interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodArray;
    exactLength: {
        value: number;
        message?: string | undefined;
    } | null;
    minLength: {
        value: number;
        message?: string | undefined;
    } | null;
    maxLength: {
        value: number;
        message?: string | undefined;
    } | null;
}
export interface ZodBooleanDef extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodBoolean;
    coerce: boolean;
}
export interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodBranded;
}
export interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    catchValue: (ctx: {
        error: ZodError;
        input: unknown;
    }) => T["_input"];
    typeName: ZodFirstPartyTypeKind.ZodCatch;
}
export interface ZodCustomIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params?: {
        [k: string]: any;
    };
}
export interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    defaultValue: () => util.noUndefined<T["_input"]>;
    typeName: ZodFirstPartyTypeKind.ZodDefault;
}
export interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    schema: T;
    typeName: ZodFirstPartyTypeKind.ZodEffects;
    effect: Effect<any>;
}
export interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodEnum;
}
export interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    left: T;
    right: U;
    typeName: ZodFirstPartyTypeKind.ZodIntersection;
}
export interface ZodInvalidArgumentsIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_arguments;
    argumentsError: ZodError;
}
export interface ZodInvalidDateIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_date;
}
export interface ZodInvalidEnumValueIssue extends ZodIssueBase {
    received: string | number;
    code: typeof ZodIssueCode.invalid_enum_value;
    options: (string | number)[];
}
export interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_intersection_types;
}
export interface ZodInvalidLiteralIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_literal;
    expected: unknown;
    received: unknown;
}
export interface ZodInvalidReturnTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_return_type;
    returnTypeError: ZodError;
}
export interface ZodInvalidStringIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_string;
    validation: StringValidation;
}
export interface ZodInvalidTypeIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_type;
    expected: ZodParsedType;
    received: ZodParsedType;
}
export interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union_discriminator;
    options: Primitive[];
}
export interface ZodInvalidUnionIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.invalid_union;
    unionErrors: ZodError[];
}
export interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {
    values: T;
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
}
export interface ZodNotFiniteIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_finite;
}
export interface ZodNotMultipleOfIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.not_multiple_of;
    multipleOf: number | bigint;
}
export interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodNullable;
}
export interface ZodNumberDef extends ZodTypeDef {
    checks: ZodNumberCheck[];
    typeName: ZodFirstPartyTypeKind.ZodNumber;
    coerce: boolean;
}
export interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    typeName: ZodFirstPartyTypeKind.ZodObject;
    shape: () => T;
    catchall: Catchall;
    unknownKeys: UnknownKeys;
}
export interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodOptional;
}
export interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {
    in: A;
    out: B;
    typeName: ZodFirstPartyTypeKind.ZodPipeline;
}
export interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    type: T;
    typeName: ZodFirstPartyTypeKind.ZodPromise;
}
export interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
    innerType: T;
    typeName: ZodFirstPartyTypeKind.ZodReadonly;
}
export interface ZodStringDef extends ZodTypeDef {
    checks: ZodStringCheck[];
    typeName: ZodFirstPartyTypeKind.ZodString;
    coerce: boolean;
}
export interface ZodTooBigIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_big;
    maximum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
export interface ZodTooSmallIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_small;
    minimum: number | bigint;
    inclusive: boolean;
    exact?: boolean;
    type: "array" | "string" | "number" | "set" | "date" | "bigint";
}
export interface ZodTupleDef<T extends ZodTupleItems | [
] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
    items: T;
    rest: Rest;
    typeName: ZodFirstPartyTypeKind.ZodTuple;
}
export interface ZodTypeDef {
    errorMap?: ZodErrorMap | undefined;
    description?: string | undefined;
}
export interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[
    ZodTypeAny,
    ZodTypeAny,
    ...ZodTypeAny[]
]>> extends ZodTypeDef {
    options: T;
    typeName: ZodFirstPartyTypeKind.ZodUnion;
}
export interface ZodUnrecognizedKeysIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.unrecognized_keys;
    keys: string[];
}
export type APIEnvironment = "test" | "development" | "sandbox" | "production" | "demo";
export type APIHeader = {
    "x-api-key"?: string;
    Authorization?: string;
};
export type APIPaths = {
    payment?: string;
    wallet?: string;
    logs?: string;
    datetime?: string;
};
export type APIResponse<T> = {
    ok: boolean;
    error?: any;
    data?: T;
    originalResponse?: string;
    statusCode?: number;
    errorCode?: "SERVER_ERROR" | "JSON_ERROR" | "PARSING_CONTENT_ERROR" | "CLIENT_ERROR";
};
export type AbstractSessionModel = {
    expiration_date: string;
};
export type Any = number | string | Currency;
export type AnyZodObject = ZodObject<any, any, any>;
export type ArrayCardinality = "many" | "atleastone";
export type AssertArray<T> = T extends any[] ? T : never;
export type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;
export type BRAND<T extends string | number | symbol> = {
    [BRAND]: {
        [k in T]: true;
    };
};
export type Beacon = {
    sendBeacon(url: string, bodyInit?: any): void;
};
export type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
    readonly [Symbol.toStringTag]: string;
} | Date | Error | Generator | Promise<unknown> | RegExp;
export type BuiltSecondaryToken = {
    number: string;
    mask: string;
    balance: number;
    partner: string;
    currencyCode: string;
    expirationDate: string;
    pinCode?: string;
};
export type CardBrand = (typeof CardBrandEnum)[keyof typeof CardBrandEnum];
export type CatchallInput<T extends ZodType> = ZodType extends T ? unknown : {
    [k: string]: T["_input"];
};
export type CatchallOutput<T extends ZodType> = ZodType extends T ? unknown : {
    [k: string]: T["_output"];
};
export type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;
export type DIRTY<T> = {
    status: "dirty";
    value: T;
};
export type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;
export type EnumLike = {
    [k: string]: string | number;
    [nu: number]: string;
};
export type EnumValues<T extends string = string> = readonly [
    T,
    ...T[]
];
export type EnvironmentTarget = typeof Environments[number];
export type ErrorMapCtx = {
    defaultError: string;
    data: any;
};
export type EventBusScopes = {
    [key: string]: string[];
};
export type EventListenerTerminator = () => void;
export type FilterEnum<Values, ToExclude> = Values extends [
] ? [
] : Values extends [
    infer Head,
    ...infer Rest
] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [
    Head,
    ...FilterEnum<Rest, ToExclude>
] : never;
export type Format = (currency?: Currency, opts?: Options) => string;
export type INVALID = {
    status: "aborted";
};
export type InitData<T extends any = void> = Omit<TypeOf<typeof InitData>, "plugin_result"> & {
    plugin_result: {
        status?: any;
        amount?: number;
    } & (T extends void ? {
        logs: any;
        payment_data?: any;
    } : T);
};
export type InitPayload = TypeOf<typeof InitPayload>;
export type InputTypeOfTuple<T extends ZodTupleItems | [
]> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_input"] : never;
}>;
export type InputTypeOfTupleWithRest<T extends ZodTupleItems | [
], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [
    ...InputTypeOfTuple<T>,
    ...Rest["_input"][]
] : InputTypeOfTuple<T>;
export type IntegratedToken = {
    brand_name?: string | null;
    created_at: string;
    description: any;
    expiration_date: string;
    favorite?: boolean | null;
    id: string;
    name?: string;
    merchant?: string | null;
    owner_reference: string;
    pin_code?: string;
    status: string;
    uniqueness_token: string;
    updated_at: string;
    value: string;
    payment_id: {
        method?: string;
        partner?: string;
        origin?: string;
    };
};
export type IpVersion = "v4" | "v6";
export type IssueData = stripPath<ZodIssueOptionalMessage> & {
    path?: (string | number)[];
    fatal?: boolean | undefined;
};
export type ItemValidationData = TypeOf<typeof ItemValidationData>;
export type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [
    infer Head,
    ...infer Tail
] ? readonly [
    Head,
    ...Tail
] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;
export type OK<T> = {
    status: "valid";
    value: T;
};
export type OutputTypeOfTuple<T extends ZodTupleItems | [
]> = AssertArray<{
    [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_output"] : never;
}>;
export type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [
], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [
    ...OutputTypeOfTuple<T>,
    ...Rest["_output"][]
] : OutputTypeOfTuple<T>;
export type OwnerTokens = Array<IntegratedToken>;
export type ParseInput = {
    data: any;
    path: (string | number)[];
    parent: ParseContext;
};
export type ParseParams = {
    path: (string | number)[];
    errorMap: ZodErrorMap;
    async: boolean;
};
export type ParsePath = ParsePathComponent[];
export type ParsePathComponent = string | number;
export type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;
export type PartnerPayload = TypeOf<typeof PartnerPayload>;
export type PassthroughType<T extends UnknownKeysParam> = T extends "passthrough" ? {
    [k: string]: unknown;
} : unknown;
export type PaymentElementEventName = "fatalError" | "formValid" | "validationRequested";
export type PaymentItemData = {
    method: string;
    partner: string;
    paymentData: any;
    partnerData: any;
    paymentPreferences: any;
    order: any;
    step_id?: number;
};
export type PaymentMethodSource = {
    contracts?: any;
    configurations: {
        template?: string | null;
        labels?: string[];
        position?: number | null;
        stable?: boolean | null;
        vault?: {
            supported_brands?: CardBrand[];
            token_scope?: string;
            vendor?: string;
            external_three_ds_enabled?: boolean;
        };
        settings?: {
            registration_mode?: "OFF_SESSION" | "ON_SESSION";
            save_token?: boolean | null;
            direct_debit?: boolean | null;
            payment_min_amount?: number | null;
            payment_max_amount?: number | null;
            usage_per_session_limit?: number | null;
            merchant_specifics?: {
                integration_mode?: "popup" | "embedded" | "redirection";
                client_id?: string;
                merchant_id?: string;
                fraudnet_enabled?: "true" | "false" | boolean;
                data_partner_attribution_id?: string;
            };
        };
    };
    integrated_tokens?: IntegratedToken[];
};
export type PaymentSessionModel = AbstractSessionModel & {
    id: string;
    protocols: Record<string, Record<string, PaymentMethodSource>>;
    amount?: number;
    currency_code: string;
    failure: string;
    success: string;
    redirection?: string;
    vault?: PaymentSessionVaultModel;
};
export type PaymentSessionVaultModel = {
    vendor_front_data: Record<string, {
        merchant_id: string;
    }>;
};
export type PaymentSplit = {
    amount: Currency;
    minIncrement?: number;
    source: PaymentItemInterface;
};
export type PaymentTokenSource = BuiltSecondaryToken | IntegratedToken;
export type PreprocessEffect<T> = {
    type: "preprocess";
    transform: (arg: T, ctx: RefinementCtx) => any;
};
export type Primitive = string | number | symbol | bigint | boolean | null | undefined;
export type PurseHeadlessCheckoutErrorCodesValues = (typeof PurseHeadlessCheckoutErrorCodes)[keyof typeof PurseHeadlessCheckoutErrorCodes] | PurseHeadlessSecondariesErrorCodesValues;
export type PurseHeadlessCheckoutEventCodes = (typeof PurseHeadlessCheckoutEventBusCodesEnum)[keyof typeof PurseHeadlessCheckoutEventBusCodesEnum];
export type PurseHeadlessCheckoutPaymentItem = PurseHeadlessCheckoutPaymentMethod | PurseHeadlessCheckoutPaymentToken;
export type PurseHeadlessCheckoutPaymentMethod = PurseHeadlessCheckoutSecondaryMethod | PurseHeadlessCheckoutPrimaryMethod;
export type PurseHeadlessCheckoutPaymentToken = PurseHeadlessCheckoutSecondaryToken | PurseHeadlessCheckoutPrimaryToken | PurseHeadlessCheckoutTemporarySecondaryToken;
/**
 * Represents a secondary payment method in the Purse checkout system.
 * Secondary methods are additional payment options like gift cards that can be combined with primary methods.
 */
export type PurseHeadlessCheckoutSecondaryMethod = PurseHeadlessCheckoutBase & PurseHeadlessCheckoutSecondaryTokenProvider & {
    /** Maximum instances of this secondary method that can be used in the split */
    limit?: number;
    /** Always true for secondary payment methods */
    isSecondary: true;
} & SecondarySpecificConfig;
export type PurseHeadlessCheckoutV1SessionData = PaymentSessionModel;
/**
 * Represents a V2 session for the Headless Checkout.
 *
 * This string contains encoded session information.
 * It is used to initialize and manage a V2 payment session.
 *
 * @typedef {string} PurseHeadlessCheckoutV2Params
 * @group Interfaces
 */
export type PurseHeadlessCheckoutV2Params = string;
export type PurseHeadlessSecondariesErrorCodesValues = (typeof PurseHeadlessSecondariesErrorCodes)[keyof typeof PurseHeadlessSecondariesErrorCodes];
export type RawCreateParams = {
    errorMap?: ZodErrorMap | undefined;
    invalid_type_error?: string | undefined;
    required_error?: string | undefined;
    message?: string | undefined;
    description?: string | undefined;
} | undefined;
export type Readable<T> = WithGetter<T> & Subscribable<T>;
export type RefinementEffect<T> = {
    type: "refinement";
    refinement: (arg: T, ctx: RefinementCtx) => any;
};
export type RegistrationState = {
    registered: boolean;
    name: string | null;
};
export type SafeParseError<Input> = {
    success: false;
    error: ZodError<Input>;
    data?: never;
};
export type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;
export type SafeParseSuccess<Output> = {
    success: true;
    data: Output;
    error?: never;
};
export type ServerDatetime = TypeOf<typeof ServerDatetime>;
export type SimulationCandidate = TypeOf<typeof SimulationCandidate>;
export type SimulationCandidatePayload = TypeOf<typeof SimulationCandidatePayload>;
/**
 * The Standard Schema interface.
 */
export type StandardSchemaV1<Input = unknown, Output = Input> = {
    /**
     * The Standard Schema properties.
     */
    readonly "~standard": StandardSchemaV1.Props<Input, Output>;
};
export type StoreInvalidator<T> = (value?: T) => void;
export type StoreSubscriber<T> = Subscriber<T>;
export type StoreUnsubscriber = () => void;
export type StoreUpdater<T> = (value: T) => T;
export type Stores = Subscribable<any> | [
    Subscribable<any>,
    ...Array<Subscribable<any>>
] | Array<Subscribable<any>>;
export type StoresValues<T> = T extends Subscribable<infer U> ? U : {
    [K in keyof T]: T[K] extends Subscribable<infer U> ? U : never;
};
export type StringValidation = "email" | "url" | "emoji" | "uuid" | "nanoid" | "regex" | "cuid" | "cuid2" | "ulid" | "datetime" | "date" | "time" | "duration" | "ip" | "cidr" | "base64" | "jwt" | "base64url" | {
    includes: string;
    position?: number | undefined;
} | {
    startsWith: string;
} | {
    endsWith: string;
};
export type Subscriber<T> = (value: T) => void;
export type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;
export type TransformEffect<T> = {
    type: "transform";
    transform: (arg: T, ctx: RefinementCtx) => any;
};
export type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
export type UnknownKeysParam = "passthrough" | "strict" | "strip";
export type Unsubscriber = () => void;
export type ValidationData = TypeOf<typeof ValidationData>;
export type ValidationPayload = TypeOf<typeof ValidationPayload>;
export type Values<T extends EnumValues> = {
    [k in T[number]]: k;
};
export type WalletSessionModel = AbstractSessionModel & {
    session_id: string;
    owner_reference: string;
    merchant: string;
};
export type Writeable<T> = {
    -readonly [P in keyof T]: T[P];
};
export type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {
    message: string;
};
export type ZodFormattedError<T, U = string> = {
    _errors: U[];
} & recursiveZodFormattedError<NonNullable<T>>;
export type ZodIssue = ZodIssueOptionalMessage & {
    fatal?: boolean | undefined;
    message: string;
};
export type ZodIssueBase = {
    path: (string | number)[];
    message?: string | undefined;
};
export type ZodIssueCode = keyof typeof ZodIssueCode;
export type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;
export type ZodNumberCheck = {
    kind: "min";
    value: number;
    inclusive: boolean;
    message?: string | undefined;
} | {
    kind: "max";
    value: number;
    inclusive: boolean;
    message?: string | undefined;
} | {
    kind: "int";
    message?: string | undefined;
} | {
    kind: "multipleOf";
    value: number;
    message?: string | undefined;
} | {
    kind: "finite";
    message?: string | undefined;
};
export type ZodParsedType = keyof typeof ZodParsedType;
export type ZodRawShape = {
    [k: string]: ZodTypeAny;
};
export type ZodStringCheck = {
    kind: "min";
    value: number;
    message?: string | undefined;
} | {
    kind: "max";
    value: number;
    message?: string | undefined;
} | {
    kind: "length";
    value: number;
    message?: string | undefined;
} | {
    kind: "email";
    message?: string | undefined;
} | {
    kind: "url";
    message?: string | undefined;
} | {
    kind: "emoji";
    message?: string | undefined;
} | {
    kind: "uuid";
    message?: string | undefined;
} | {
    kind: "nanoid";
    message?: string | undefined;
} | {
    kind: "cuid";
    message?: string | undefined;
} | {
    kind: "includes";
    value: string;
    position?: number | undefined;
    message?: string | undefined;
} | {
    kind: "cuid2";
    message?: string | undefined;
} | {
    kind: "ulid";
    message?: string | undefined;
} | {
    kind: "startsWith";
    value: string;
    message?: string | undefined;
} | {
    kind: "endsWith";
    value: string;
    message?: string | undefined;
} | {
    kind: "regex";
    regex: RegExp;
    message?: string | undefined;
} | {
    kind: "trim";
    message?: string | undefined;
} | {
    kind: "toLowerCase";
    message?: string | undefined;
} | {
    kind: "toUpperCase";
    message?: string | undefined;
} | {
    kind: "jwt";
    alg?: string;
    message?: string | undefined;
} | {
    kind: "datetime";
    offset: boolean;
    local: boolean;
    precision: number | null;
    message?: string | undefined;
} | {
    kind: "date";
    message?: string | undefined;
} | {
    kind: "time";
    precision: number | null;
    message?: string | undefined;
} | {
    kind: "duration";
    message?: string | undefined;
} | {
    kind: "ip";
    version?: IpVersion | undefined;
    message?: string | undefined;
} | {
    kind: "cidr";
    version?: IpVersion | undefined;
    message?: string | undefined;
} | {
    kind: "base64";
    message?: string | undefined;
} | {
    kind: "base64url";
    message?: string | undefined;
};
export type ZodTupleItems = [
    ZodTypeAny,
    ...ZodTypeAny[]
];
export type ZodTypeAny = ZodType<any, any, any>;
export type ZodUnionOptions = Readonly<[
    ZodTypeAny,
    ...ZodTypeAny[]
]>;
export type allKeys<T> = T extends any ? keyof T : never;
export type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> = Cardinality extends "atleastone" ? [
    T["_output"],
    ...T["_output"][]
] : T["_output"][];
export type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
    [k in keyof Shape]: Shape[k]["_input"];
}>;
export type baseObjectOutputType<Shape extends ZodRawShape> = {
    [k in keyof Shape]: Shape[k]["_output"];
};
export type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;
export type input<T extends ZodType<any, any, any>> = T["_input"];
export type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<baseObjectInputType<Shape>> & CatchallInput<Catchall> & PassthroughType<UnknownKeys>;
export type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>> & CatchallOutput<Catchall> & PassthroughType<UnknownKeys>;
export type output<T extends ZodType<any, any, any>> = T["_output"];
export type recursiveZodFormattedError<T> = T extends [
    any,
    ...any[]
] ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : T extends any[] ? {
    [k: number]: ZodFormattedError<T[number]>;
} : T extends object ? {
    [K in keyof T]?: ZodFormattedError<T[K]>;
} : unknown;
export type stripPath<T extends object> = T extends any ? util.OmitKeys<T, "path"> : never;
export type typeToFlattenedError<T, U = string> = {
    formErrors: U[];
    fieldErrors: {
        [P in allKeys<T>]?: U[];
    };
};
export type typecast<A, T> = A extends T ? A : never;
interface Event$1<Payload = any> {
    code: string;
    type: EventType;
    dateString: string;
    payload?: Payload;
}
type EventListener$1<EventType extends Event$1> = (event: EventType) => void;

export {
    HostedFormUIOptions as PurseHeadlessCheckoutHostedFormUIOptions,
    Options$1 as PurseHeadlessCheckoutUIOptions,
    PartnerUIOptionsTheme as PurseHeadlessCheckoutPartnerUIOptionsTheme,
    PartnerUITheme as PurseHeadlessCheckoutPartnerUITheme,
    XPayButtonUIOptions as PurseHeadlessCheckoutXPayButtonUIOptions,
};

export as namespace Purse;

export {};
